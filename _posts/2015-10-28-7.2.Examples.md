---
layout: post
title:  "7.2. Примеры. 7.2.1. Пример: фильтр"
date:   2015-10-28 22:00:00
categories: go
---

Несмотря на небольшое количество синтаксических конструкций
поддержки go-подпрограмм и каналов в языке Go (<-, chan, go,
select), их вполне достаточно для реализации параллельных алгоритмов множеством различных способов. Фактически различных
способов так много, что невозможно покрыть их все в одной главе.
Поэтому мы рассмотрим три шаблона, наиболее часто используемых
при создании параллельных программ, – конвейер, множество независимых параллельно выполняемых заданий (с синхронизацией
результатов и без) и множество взаимозависимых параллельно выполняемых заданий – и исследуем конкретные способы их реализации с применением механизмов параллельного выполнения, имеющихся в языке Go.

Примеры и упражнения в конце главы позволят получить достаточный объем знаний и навыков параллельного программирования
на языке Go, чтобы уверенно применять их при создании новых
программ.

## 7.2.1. Пример: фильтр

Этот первый пример создавался с целью продемонстрировать отдельный шаблон параллельного программирования. Программа легко может быть адаптирована для любой другой работы, где параллельное выполнение может принести выгоду.

Читатели, знакомые с операционной системой Unix, могут заметить, что каналы в языке Go напоминают конвейеры в Unix (за исключением того, что каналы являются двунаправленными, а конвейеры – однонаправленными). Такие конвейеры можно использовать
для организации конвейерной обработки, где вывод одной программы
подается на ввод другой программы, чей вывод, в свою очередь, подается на ввод третьей программы, и т. д. Например, чтобы получить
список всех файлов с исходными текстами на языке Go, находящихся в дереве загружаемых примеров (исключая тестовые файлы), в
Unix можно воспользоваться следующим конвейером команд: find
$GOROOT/src -name "*.go" | grep -v test.go. Одна из замечательных
сторон такого подхода состоит в том, что конвейеры легко расширяются. Например, можно добавить | xargs wc -l, чтобы для каждого
перечисленного файла получить количество строк в нем (плюс общее
число строк в конце), и | sort -n, чтобы отсортировать файлы по
количеству строк в них (в порядке возрастания).

Настоящие конвейеры в стиле Unix можно создавать с помощью
функции io.Pipe() из стандартной библиотеки. Например, стандартная библиотека Go использует эту функцию для сравнения
изображений (см. файл go/src/pkg/image/png/reader_test.go).

Помимо функции io.Pipe() , создавать конвейеры в стиле Unix
можно также с помощью каналов, и этот последний прием будет
рассмотрен здесь.

Пример программы filter (в файле filter/filter.go) принимает
несколько аргументов командной строки (например, определяющие
минимальный и максимальный размеры файлов и допустимые расширения имен файлов) и список файлов и выводит имена файлов из списка, соответствующие критериям, заданным в командной строке. Ниже
приводится тело функции main() программы, состоящее из двух строк.


{% highlight go %}  
minSize, maxSize, suffixes, files := handleCommandLine()
sink(filterSize(minSize, maxSize, filterSuffixes(suffixes, source(files))))
{% endhighlight %}

Для обработки аргументов командной строки функция
handleCommandLine() (здесь не показана) использует пакет flag из
стандартной библиотеки. Конвейер работает в направлении от самого внутреннего вызова функции (source(files)) к самому внешнему
(sink()). Ниже представлен тот же конвейер, только в более простом
для понимания виде.

{% highlight go %}  
channel1 := source(files)
channel2 := filterSuffixes(suffixes, channel1)
channel3 := filterSize(minSize, maxSize, channel2)
sink(channel3)
{% endhighlight %}

Функция source() принимает срез с именами файлов и возвращает канал типа chan string, который присваивается переменной
channel1. Функция source() посылает в канал каждое имя файла
по очереди. Далее следуют вызовы двух фильтрующих функций,
каждая из которых принимает критерии фильтрации и канал типа
chan string и возвращает собственный канал типа chan string. В
этом примере переменной channel2 присваивается канал, возвращаемый первым фильтром, переменной channel3 – канал, возвращаемый
вторым фильтром. Фильтры выполняют итерации по элементам в
канале и посылают каждый элемент, соответствующий их критериям, в канал, возвращаемый ими. Функция sink() принимает канал,
выполняет итерации по его элементам и выводит их.

!["Рис. 7.4. Конвейер go-подпрограмм"](/images/ris-7-4.jpg "Рис. 7.4. Конвейер go-подпрограмм")

На рис. 7.4 схематически изображено, что происходит. В данном
случае функция sink() выполняется в главной go-подпрограмме,
а все остальные функции, составляющие конвейер (source(),
filterSuffixes() и filterSize()), выполняются в собственных goподпрограммах. Это означает, что каждая конвейерная функция
возвращает управление немедленно и выполнение быстро достигает
функции sink(). В этот момент все go-подпрограммы выполняются
параллельно, ожидая отправки или приема, пока не будут обработаны все имена файлов.

{% highlight go %}  
func source(files []string) <-chan string {
	out := make(chan string, 1000)
	go func() {
		for _, filename := range files {
			out <- filename
		}
		close(out)
	}()
	return out
}
{% endhighlight %}

Эта функция создает канал для передачи имен файлов. Она использует буферизованный канал, поскольку это обеспечивает лучшую производительность в тестах. (Как это нередко бывает, за высокую скорость работы приходится платить повышенным расходом
памяти.)

Вслед за каналом создается go-подпрограмма, выполняющая
итерации по именам файлов и посылающая каждое имя в канал.
Когда все имена файлов будут отправлены, канал закрывается. Как
обычно, инструкция go возвращает управление немедленно, поэтому между посылкой первого и последнего имен файла и закрытием
канала может пройти значительный промежуток времени. Операция
посылки в канал не блокируется (по крайней мере, для первой тысячи имен файлов или для всех имен, если их меньше тысячи), но
будет блокироваться при посылке большого количества элементов,
по крайней мере пока из канала не будет принят один или более
элементов.

Как отмечалось выше, по умолчанию каналы создаются двунаправленными, но имеется возможность создать однонаправленный
канал. В предыдущем разделе говорилось, что тип chan<- Тип соответствует каналу, доступному только для отправки, а тип <-chan
Тип – доступному только для приема. В конце функция возвращает
двунаправленный канал как однонаправленный, доступный только
для приема. Разумеется, можно было бы вернуть его как двунаправленный канал, однако использованный способ лучше выражает намерения программиста.

После выполнения инструкции go, запускающей анонимную
функцию в отдельной go-подпрограмме, функция немедленно вернет канал, через который go-подпрограмма будет посылать имена
файлов. То есть после вызова функции source() в программе будут
выполняться две go-подпрограммы – главная go-подпрограмма и дополнительная, созданная в функции.

{% highlight go %}  
func filterSuffixes(suffixes []string, in <-chan string) <-chan string {
	out := make(chan string, cap(in))
	go func() {
		for filename := range in {
			if len(suffixes) == 0 {
				out <- filename
				continue
			}
			ext := strings.ToLower(filepath.Ext(filename))
			for _, suffix := range suffixes {
				if ext == suffix {
					out <- filename
					break
				}
			}
		}
		close(out)
	}()
	return out
}
{% endhighlight %}

Это первая из двух функций-фильтров и единственная, показанная здесь, потому что функция filterSize() имеет практически такую же структуру.

Канал, передаваемый в параметре in, может быть двунаправленным или доступным только для приема, но в любом случае объявление типа гарантирует, что внутри функции filterSuffixes()
он будет использоваться только для приема. (И, как стало понятно
после знакомства с возвращаемым значением функции source(), канал in действительно доступен только для приема.) Соответственно,
здесь, как и в функции source(), двунаправленный канал возвращается как доступный только для приема. В обоих случаях можно
было бы убрать стрелки <-, и функции действовали бы точно так
же. Однако добавление оператора направления точнее выражает
семантику работы функции и гарантирует, что компилятор строго
будет следить за ее соблюдением.

Функция filterSuffixes() начинается с создания канала вывода
с размером буфера, совпадающим с размером буфера канала ввода,
обеспечивая тем самым максимальную пропускную способность. Затем создается go-подпрограмма для обработки имен файлов. Внутри
go-подпрограммы выполняются итерации по элементам в канале in
(то есть по именам файлов). Если допустимые расширения не были
указаны, тогда допустимыми считаются все расширения и принятые
имена файлов просто посылаются в канал вывода. Если расширения
были указаны и расширение в имени файла, после приведения его
к нижнему регистру, совпадает с любым из них, это имя посылается в канал вывода, в противном случае оно просто отбрасывается. (Функция filepath.Ext() возвращает расширение имени файла,
включая точку в начале, или пустую строку, если расширение в имени отсутствует.)

Как и в функции source(), после обработки всех имен файлов
канал вывода закрывается, хотя до этого момента может пройти
некоторое время. После создания go-подпрограммы канал вывода
возвращается вызывающей программе, чтобы следующая функция
в конвейере смогла принимать из него имена файлов.

В этот момент действуют три go-подпрограммы – главная
go-подпрограмма, go-подпрограмма с функцией source() и goподпрограмма с данной функцией. А после вызова функции
filterSize() будут выполняться уже четыре go-подпрограммы, причем одновременно.

{% highlight go %}  
func sink(in <-chan string) {
	for filename := range in {
		fmt.Println(filename)
	}
}
{% endhighlight %}

Функция source() и две функции фильтров действуют в собственных go-подпрограммах, взаимодействуя друг с другом посредством
каналов. Функция sink() выполняется в главной go-подпрограмме и
получает данные из последнего канала, созданного второй функцией-фильтром. Она производит итерации по именам файлов, успешно
прошедших фильтры (если таковые имеются), и выводит их.

Инструкция for ... range в функции sink() выполняет итерации
по элементам в канале in, выводит имена файлов или блокируется
операцией приема, пока канал не будет закрыт, это гарантирует, что
главная go-подпрограмма не завершится, пока не будут обработаны
все имена файлов в других go-подпрограммах.

Естественно, в конвейер можно добавить и другие функции, для
фильтрации имен файлов по дополнительным критериям или обработки имен, прошедших фильтры, главное, чтобы каждая новая
функция принимала канал ввода (канал вывода предыдущей функции) и возвращала собственный канал вывода. И конечно, в случае
необходимости передавать более сложные значения каналы можно
создавать на основе структур, а не только на основе простых строк.

Реализация, представленная в этом подразделе, является отличной иллюстрацией конвейера, однако здесь на каждой стадии выполняется слишком простая обработка данных, чтобы можно было
рассчитывать на какие-то выгоды от конвейерного подхода. Выигрыш от применения конвейера будет значительно больше, если
на каждой стадии будет выполняться большой объем работ, такой,
что каждая go-подпрограмма большую часть времени будет занята
работой.
