---
layout: post
title:  "7.2. Примеры. 7.2.1. Пример: фильтр"
date:   2015-10-28 22:00:00
categories: go
---

Несмотря на небольшое количество синтаксических конструкций
поддержки go-подпрограмм и каналов в языке Go (<-, chan, go,
select), их вполне достаточно для реализации параллельных алго-
ритмов множеством различных способов. Фактически различных
способов так много, что невозможно покрыть их все в одной главе.
Поэтому мы рассмотрим три шаблона, наиболее часто используемых
при создании параллельных программ, – конвейер, множество не-
зависимых параллельно выполняемых заданий (с синхронизацией
результатов и без) и множество взаимозависимых параллельно вы-
полняемых заданий – и исследуем конкретные способы их реали-
зации с применением механизмов параллельного выполнения, име-
ющихся в языке Go.

Примеры и упражнения в конце главы позволят получить доста-
точный объем знаний и навыков параллельного программирования
на языке Go, чтобы уверенно применять их при создании новых
программ.

## 7.2.1. Пример: фильтр

Этот первый пример создавался с целью продемонстрировать от-
дельный шаблон параллельного программирования. Программа лег-
ко может быть адаптирована для любой другой работы, где парал-
лельное выполнение может принести выгоду.

Читатели, знакомые с операционной системой Unix, могут заме-
тить, что каналы в языке Go напоминают конвейеры в Unix (за ис-
ключением того, что каналы являются двунаправленными, а конвей-
еры – однонаправленными). Такие конвейеры можно использовать
для организации конвейерной обработки, где вывод одной программы
подается на ввод другой программы, чей вывод, в свою очередь, по-
дается на ввод третьей программы, и т. д. Например, чтобы получить
список всех файлов с исходными текстами на языке Go, находящих-
ся в дереве загружаемых примеров (исключая тестовые файлы), в
Unix можно воспользоваться следующим конвейером команд: find
$GOROOT/src -name "*.go" | grep -v test.go. Одна из замечательных
сторон такого подхода состоит в том, что конвейеры легко расширя-
ются. Например, можно добавить | xargs wc -l, чтобы для каждого
перечисленного файла получить количество строк в нем (плюс общее
число строк в конце), и | sort -n, чтобы отсортировать файлы по
количеству строк в них (в порядке возрастания).

Настоящие конвейеры в стиле Unix можно создавать с помощью
функции io.Pipe() из стандартной библиотеки. Например, стан-
дартная библиотека Go использует эту функцию для сравнения
изображений (см. файл go/src/pkg/image/png/reader_test.go).

Помимо функции io.Pipe() , создавать конвейеры в стиле Unix
можно также с помощью каналов, и этот последний прием будет
рассмотрен здесь.

Пример программы filter (в файле filter/filter.go) принимает
несколько аргументов командной строки (например, определяющие
минимальный и максимальный размеры файлов и допустимые расши-
рения имен файлов) и список файлов и выводит имена файлов из спи-
ска, соответствующие критериям, заданным в командной строке. Ниже
приводится тело функции main() программы, состоящее из двух строк.


{% highlight perl %}  
minSize, maxSize, suffixes, files := handleCommandLine()
sink(filterSize(minSize, maxSize, filterSuffixes(suffixes, source(files))))
{% endhighlight %}

Для обработки аргументов командной строки функция
handleCommandLine() (здесь не показана) использует пакет flag из
стандартной библиотеки. Конвейер работает в направлении от само-
го внутреннего вызова функции (source(files)) к самому внешнему
(sink()). Ниже представлен тот же конвейер, только в более простом
для понимания виде.

{% highlight perl %}  
channel1 := source(files)
channel2 := filterSuffixes(suffixes, channel1)
channel3 := filterSize(minSize, maxSize, channel2)
sink(channel3)
{% endhighlight %}

Функция source() принимает срез с именами файлов и возвра-
щает канал типа chan string, который присваивается переменной
channel1. Функция source() посылает в канал каждое имя файла
по очереди. Далее следуют вызовы двух фильтрующих функций,
каждая из которых принимает критерии фильтрации и канал типа
chan string и возвращает собственный канал типа chan string. В
этом примере переменной channel2 присваивается канал, возвращае-
мый первым фильтром, переменной channel3 – канал, возвращаемый
вторым фильтром. Фильтры выполняют итерации по элементам в
канале и посылают каждый элемент, соответствующий их критери-
ям, в канал, возвращаемый ими. Функция sink() принимает канал,
выполняет итерации по его элементам и выводит их.

!["Рис. 7.4. Конвейер go-подпрограмм"](/images/ris-7-4.jpg "Рис. 7.4. Конвейер go-подпрограмм")

На рис. 7.4 схематически изображено, что происходит. В данном
случае функция sink() выполняется в главной go-подпрограмме,
а все остальные функции, составляющие конвейер (source(),
filterSuffixes() и filterSize()), выполняются в собственных go-
подпрограммах. Это означает, что каждая конвейерная функция
возвращает управление немедленно и выполнение быстро достигает
функции sink(). В этот момент все go-подпрограммы выполняются
параллельно, ожидая отправки или приема, пока не будут обрабо-
таны все имена файлов.

{% highlight perl %}  
func source(files []string) <-chan string {
	out := make(chan string, 1000)
	go func() {
		for _, filename := range files {
			out <- filename
		}
		close(out)
	}()
	return out
}
{% endhighlight %}

Эта функция создает канал для передачи имен файлов. Она ис-
пользует буферизованный канал, поскольку это обеспечивает луч-
шую производительность в тестах. (Как это нередко бывает, за вы-
сокую скорость работы приходится платить повышенным расходом
памяти.)

Вслед за каналом создается go-подпрограмма, выполняющая
итерации по именам файлов и посылающая каждое имя в канал.
Когда все имена файлов будут отправлены, канал закрывается. Как
обычно, инструкция go возвращает управление немедленно, поэто-
му между посылкой первого и последнего имен файла и закрытием
канала может пройти значительный промежуток времени. Операция
посылки в канал не блокируется (по крайней мере, для первой ты-
сячи имен файлов или для всех имен, если их меньше тысячи), но
будет блокироваться при посылке большого количества элементов,
по крайней мере пока из канала не будет принят один или более
элементов.

Как отмечалось выше, по умолчанию каналы создаются двуна-
правленными, но имеется возможность создать однонаправленный
канал. В предыдущем разделе говорилось, что тип chan<- Тип со-
ответствует каналу, доступному только для отправки, а тип <-chan
Тип – доступному только для приема. В конце функция возвращает
двунаправленный канал как однонаправленный, доступный только
для приема. Разумеется, можно было бы вернуть его как двунаправ-
ленный канал, однако использованный способ лучше выражает на-
мерения программиста.

После выполнения инструкции go, запускающей анонимную
функцию в отдельной go-подпрограмме, функция немедленно вер-
нет канал, через который go-подпрограмма будет посылать имена
файлов. То есть после вызова функции source() в программе будут
выполняться две go-подпрограммы – главная go-подпрограмма и до-
полнительная, созданная в функции.

{% highlight perl %}  
func filterSuffixes(suffixes []string, in <-chan string) <-chan string {
	out := make(chan
	chan string, cap(in))
	go func() {
		for filename := range in {
			if len(suffixes) == 0 {
				out <- filename
				continue
			}
			ext := strings.ToLower(filepath.Ext(filename))
			for _, suffix := range suffixes {
				if ext == suffix {
					out <- filename
					break
				}
			}
		}
		close(out)
	}()
	return out
}
{% endhighlight %}

Это первая из двух функций-фильтров и единственная, показан-
ная здесь, потому что функция filterSize() имеет практически та-
кую же структуру.

Канал, передаваемый в параметре in, может быть двунаправлен-
ным или доступным только для приема, но в любом случае объ-
явление типа гарантирует, что внутри функции filterSuffixes()
он будет использоваться только для приема. (И, как стало понятно
после знакомства с возвращаемым значением функции source(), ка-
нал in действительно доступен только для приема.) Соответственно,
здесь, как и в функции source(), двунаправленный канал возвра-
щается как доступный только для приема. В обоих случаях можно
было бы убрать стрелки <-, и функции действовали бы точно так
же. Однако добавление оператора направления точнее выражает
семантику работы функции и гарантирует, что компилятор строго
будет следить за ее соблюдением.

Функция filterSuffixes() начинается с создания канала вывода
с размером буфера, совпадающим с размером буфера канала ввода,
обеспечивая тем самым максимальную пропускную способность. За-
тем создается go-подпрограмма для обработки имен файлов. Внутри
go-подпрограммы выполняются итерации по элементам в канале in
(то есть по именам файлов). Если допустимые расширения не были
указаны, тогда допустимыми считаются все расширения и принятые
имена файлов просто посылаются в канал вывода. Если расширения
были указаны и расширение в имени файла, после приведения его
к нижнему регистру, совпадает с любым из них, это имя посыла-
ется в канал вывода, в противном случае оно просто отбрасывает-
ся. (Функция filepath.Ext() возвращает расширение имени файла,
включая точку в начале, или пустую строку, если расширение в име-
ни отсутствует.)

Как и в функции source(), после обработки всех имен файлов
канал вывода закрывается, хотя до этого момента может пройти
некоторое время. После создания go-подпрограммы канал вывода
возвращается вызывающей программе, чтобы следующая функция
в конвейере смогла принимать из него имена файлов.

В этот момент действуют три go-подпрограммы – главная
go-подпрограмма, go-подпрограмма с функцией source() и go-
подпрограмма с данной функцией. А после вызова функции
filterSize() будут выполняться уже четыре go-подпрограммы, при-
чем одновременно.

{% highlight perl %}  
func sink(in <-chan string) {
	for filename := range in {
		fmt.Println(filename)
	}
}
{% endhighlight %}

Функция source() и две функции фильтров действуют в собствен-
ных go-подпрограммах, взаимодействуя друг с другом посредством
каналов. Функция sink() выполняется в главной go-подпрограмме и
получает данные из последнего канала, созданного второй функци-
ей-фильтром. Она производит итерации по именам файлов, успешно
прошедших фильтры (если таковые имеются), и выводит их.

Инструкция for ... range в функции sink() выполняет итерации
по элементам в канале in, выводит имена файлов или блокируется
операцией приема, пока канал не будет закрыт, это гарантирует, что
главная go-подпрограмма не завершится, пока не будут обработаны
все имена файлов в других go-подпрограммах.

Естественно, в конвейер можно добавить и другие функции, для
фильтрации имен файлов по дополнительным критериям или об-
работки имен, прошедших фильтры, главное, чтобы каждая новая
функция принимала канал ввода (канал вывода предыдущей функ-
ции) и возвращала собственный канал вывода. И конечно, в случае
необходимости передавать более сложные значения каналы можно
создавать на основе структур, а не только на основе простых строк.

Реализация, представленная в этом подразделе, является отлич-
ной иллюстрацией конвейера, однако здесь на каждой стадии вы-
полняется слишком простая обработка данных, чтобы можно было
рассчитывать на какие-то выгоды от конвейерного подхода. Вы-
игрыш от применения конвейера будет значительно больше, если
на каждой стадии будет выполняться большой объем работ, такой,
что каждая go-подпрограмма большую часть времени будет занята
работой.
