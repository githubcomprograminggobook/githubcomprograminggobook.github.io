---
layout: post
title:  "3. Строки"
date:   2015-09-18 21:27:00
categories: go
---

В этой главе рассматриваются тип string и основные пакеты из стан-
дартной библиотеки для работы со строками. В отдельных разделах
главы рассказывается, как записываются строковые литералы и как
используются строковые операторы, как индексировать строки и из-
влекать срезы (подстроки) из строк и как форматировать вывод строк,
чисел и других значений, встроенных и пользовательских типов.
Высокоуровневые средства языка Go для работы со строками,
такие как цикл for ...range, позволяющий выполнять итерации
по символам строк, функции из пакетов strings и strconv и воз-
можность извлечения срезов строк, включают все необходимое для
решения повседневных задач. Тем не менее в этой главе подробно
рассматриваются особенности строк в языке Go, включая низкоу-
ровневые, такие как внутреннее представление строк. Низкоуровне-
вые аспекты строк представляют определенный интерес, и их знание
может пригодиться в некоторых ситуациях.

Строки в языке Go являются неизменяемыми последовательно-
стями произвольных байтов. В большинстве случаев байты в строках
представляют текст Юникода в кодировке UTF-8 (см. врезку «Юни-
код» выше). Наличие поддержки Юникода означает, что строки в
языке Go могут содержать текст на смеси любых языков, известных
в мире, без ограничений, накладываемых кодовыми страницами.

Тип string в языке Go в корне отличается от эквивалентных
типов во многих других языках. Тип String в языке Java, std::string
в языке C++ и str – в Python 3 – все они являются последователь-
ностями символов фиксированного размера (с некоторыми ограниче-
ниями), тогда как строки в языке Go являются последовательностя-
ми символов переменного размера , где каждый символ может быть
представлен одним или более байтами, обычно в кодировке UTF-8.

На первый взгляд может показаться, что строки в других языках
удобнее, чем строки в языке Go, потому что они позволяют обращать-
ся к символам непосредственно, что в языке Go возможно, только
если строка состоит исключительно из 7-битных символов ASCII (так
как в кодировке UTF-8 каждый из них представлен единственным
байтом). Однако с практической точки зрения подобное отличие не
является проблемой для программистов на языке Go: во-первых, по-
тому что прямое обращение к символам нечасто бывает необходимо
благодаря поддержке итераций по символам строк; во-вторых, потому
что стандартная библиотека содержит исчерпывающий набор функ-
ций для работы со строками; и в-третьих, потому что в языке Go
строки всегда можно преобразовать в срезы с кодовыми пунктами
Юникода (типа []rune) и обращаться к ним непосредственно.

Хранение текста в кодировке UTF-8 имеет определенные пре-
имущества, по сравнению, скажем, со строками в языке Java или
Python, каждый из которых также поддерживает строки Юникода.
В языке Java строки представлены последовательностями кодовых
пунктов, каждый из которых занимает 16 бит; в Python, в версиях
с 2.x по 3.2, используется тот же подход, но в нем для хранения
кодовых пунктов отводятся 16 или 32 бита, в зависимости от пара-
метров сборки Python. Это означает, что для текста на английском
языке в Go отводится по 8 бит на каждый символ, тогда как в Java
и Python – как минимум в два раза больше. Еще одно преимущество
заключается в том, что при использования кодировки UTF-8 аппа-
ратный порядок следования байтов не имеет значения, тогда как при
использовании кодировок UTF-16 и UTF-32 его необходимо учиты-
вать (например, чтобы обеспечить корректное декодирование текста,
может потребоваться использовать кодировку UTF-16 с обратным
порядком следования байт). Кроме того, учитывая, что кодировка
UTF-8 фактически стала стандартом кодирования текстовых фай-
лов во всем мире, в других языках программирования приходится
кодировать и декодировать такие файлы, чтобы обеспечить преоб-
разование их содержимого во внутреннее представление Юникода и
обратно, тогда как в Go можно непосредственно читать и записывать
такие файлы. Помимо этого, некоторые крупные библиотеки (такие
как GTK+) уже используют строки символов в кодировке UTF-8,
поэтому программы на языке Go могут работать с ними, минуя этап
кодирования/декодирования.

Фактически строки в языке Go столь же удобны и просты в ис-
пользовании, как и в других языках. Это станет очевидно, как только
вы познакомитесь с идиомами работы со строками в языке Go.

## 3.1. Литералы, операторы и экранированные последовательности

Строковые литералы определяются с помощью кавычек (" ) или об-
ратных апострофов (`). Кавычки используются для определения ин-
терпретируемых строковых литералов – такие строки поддерживают
экранированные последовательности , перечисленные в табл. 3.1 (ни-
же), но они не могут занимать несколько строк в программе. Обрат-
ные апострофы используются для определения обычных строковых
литералов, такие строки могут занимать несколько строк в программе,
но они не поддерживают экранированных последовательностей и мо-
гут содержать любые символы, кроме обратных апострофов. Интер-
претируемые строковые литералы используются чаще, но для записи
многострочных сообщений, разметки HTML и регулярных выраже-
ний удобнее использовать строковые литералы в обратных апостро-
фах. Ниже приводятся несколько примеров литералов.

{% highlight go %}  
text1 := "\"what’s that?\", he said" // Интерпретируемый строковый литерал
text2 := `"what’s that?", he said` // Простой строковый литерал
radicals := " \u221A \U0000221a" // radicals == "  "
{% endhighlight %}

-- Таблица 3.1. Экранированные последовательности

В этом примере были созданы три переменные типа string, при
этом переменные text1 и text2 содержат один и тот же текст. По-
скольку для файлов с расширением .go используется кодировка
UTF-8, в них можно включать любые символы Юникода. Однако
сохраняется возможность использовать экранированные последо-
вательности Юникода, как это сделано для второго и третьего сим-
волов . Здесь невозможно использовать 8-битное восьмеричное
или шестнадцатеричное представление кодового пункта, так как
они ограничены диапазоном от U+0000 до U+00FF, слишком узко-
го для представления кодового пункта U+221A, соответствующего
символу .

Если потребуется определить длинный и интерпретируемый
строковый литерал, разместив его на нескольких строках в тексте
программы, можно разбить его на несколько литералов и объеди-
нить их оператором конкатенации (+ ). Кроме того, несмотря на то
что строки в языке Go являются неизменяемыми , они поддерживают
оператор добавления += . Он замещает имеющуюся строку результа-
том конкатенации двух строк, если емкости исходной строки недо-
статочно для размещения добавляемой строки. Эти операторы пере-
числены в табл. 3.2 (ниже). Строки могут сравниваться с помощью
операторов сравнения (см. табл. 2.3 выше). Ниже демонстрируется
использование этих операторов:

{% highlight go %}  
book := "The Spirit Level" + " by Richard Wilkinson" // Конкатенация строк
book += " and Kate Pickett"							 // Добавление в конец строки
fmt.Println("Josey" < "Jos ï ", "Josey" == "Jos ï ") // Сравнение строк
{% endhighlight %}

В результате выполнения этого фрагмента переменная book бу-
дет содержать текст «The Spirit Level by Richard Wilkinson and Kate
Pickett», а в поток os.Stdout будет выведена строка «true false».

## 3.2. Сравнение строк

-- Таблица 3.2. Операции со строками

Как уже отмечалось, строки в языке Go поддерживают обычные
операторы сравнения (<, <=, ==, !=, >, >=), перечисленные в табл. 2.3
(выше). Сравнение строк этими операторами выполняется побайтно.
Строки могут сравниваться непосредственно, например на равенство,
и косвенно, например когда оператор < используется для сравнения
строк с целью сортировки содержимого среза []string. К сожалению,
при выполнении сравнения могут возникать три проблемы. 1
Эти проблемы проявляются во всех языках программирования,
поддерживающих строки Юникода, и не являются характерными
только для языка Go.

Первая проблема – в том, что некоторые символы Юникода могут
быть представлены двумя и более разными последовательностями
байт. Например, символ Å может обозначать единицу измерения рас-
стояний «ангстрем» или быть простым символом A с кружочком над
ним – оба символа часто не различимы на глаз. Символу «ангстрем» в
Юникоде соответствует кодовый пункт U+212B, а символу A с кружоч-
ком над ним – кодовый пункт U+00C5 или два кодовых пункта U+0041
(A) и U+030A (° – дополнительный кружок сверху). В кодировке UTF-8
символ «ангстрем» ( Å ) представляет последовательность байтов [0xE2,
0x84, 0xAB], символ Å – последовательность [0xC3, 0x85], а символ A с
дополнительным символом ° – последовательность [0x41, 0xCC, 0x81].
Разумеется, с точки зрения пользователя, оба символа Ë ничем не отли-
чаются и при сравнении должны определяться как одинаковые, незави-
симо от того, какими последовательностями байтов они представлены.

Первая проблема не столь существенна, как может показаться,
потому что для всех последовательностей байт (то есть строк) в ко-
дировке UTF-8 в языке Go воспроизводятся одни и те же кодовые
пункты. Это означает, например, что символ é в языке Go, в сим-
вольных или в строковых литералах, всегда будет представлен од-
ной и той же последовательностью байтов. И конечно же при работе
с текстом, состоящим исключительно из символов ASCII (то есть
на английском языке), эта проблема вообще никак не проявляется.
И даже при работе с текстом, содержащим не-ASCII символы, про-
блема возникает, только когда существуют два разных символа, име-
ющих одинаковое начертание, или когда байты UTF-8 поступают в
программу из внешних источников, использующих допустимые, но
другие отображения кодовых пунктов в последовательности байтов.
Если это обстоятельство превращается в действительно серьезную
проблему, всегда можно написать собственную функцию нормали-
зации , гарантирующую, например, что символ é всегда будет пред-
ставлен последовательностью байтов [0xC3, 0xA9] (используемой
в языке Go по умолчанию), а не, к примеру, последовательностью
[0x65, 0xCC, 0x81] (то есть комбинацией символов e и  ́ ). Принципы
нормализации символов Юникода подробно разъясняются в доку-
менте «Unicode Normalization Forms» (формы нормализации Юни-
кода) (unicode.org/reports/tr15). На момент написания этих строк в
состав стандартной библиотеки языка Go входил эксперименталь-
ный пакет, реализующий нормализацию (exp/norm).

Поскольку первая проблема в действительности проявляется,
только когда дело доходит до обработки строк, поступающих из
внешних источников, и только если используется иной принцип
отображения кодовых пунктов в последовательности байтов, от-
личный от принятого в языке Go, лучшим ее решением будет изо-
ляция программного кода, принимающего внешние данные. При та-
ком подходе изолированный код мог бы выполнять нормализацию
принимаемых строк до того, как они попадут в программу.

Вторая проблема в том, что бывают ситуации, когда пользователи
могут вполне обоснованно ожидать, что разные символы должны
определяться как равные. Например, пользуясь программой, осу-
ществляющей поиск по тексту , пользователь может ввести слово
«file». Естественно, он надеется, что программа отыщет все вхожде-
ния слова «file», а также все вхождения «fi-le» (то есть слог «fi» в
конце одной строки, за которым следует слог «le» в начале следу-
ющей). Аналогично он может надеяться отыскать по строке поиска
«5» все вхождения «5», « 5 », « 5 » и даже «g». Как и первая, эта про-
блема решается с помощью нормализации некоторого вида.

Третья проблема состоит в том, что порядок сортировки некоторых
символов зависит от языка, на котором набран текст. Например, в
шведском алфавите символ ä следует за символом z, тогда как в теле-
фонных справочниках на немецком языке символ ä при сортировке
соответствует паре символов ae, а в словарях немецкого языка он со-
ответствует символу a. Еще один пример: в английском языке символ
ø при сортировке соответствует символу o, а в датском и норвежском
языках он должен следовать за символом z. Существует не только
огромное количество правил, подобных упомянутым, но они еще ос-
ложняются тем обстоятельством, что иногда одно и то же приложение
могут использовать люди разных национальностей (ожидающие по-
лучить разный порядок сортировки). Кроме того, иногда строки мо-
гут содержать слова на разных языках (например, несколько слов на
испанском и несколько слов на английском), а к некоторым символам
(таким как стрелки, типографские знаки и математические символы)
вообще неприменимо понятие порядка следования.

Но большим плюсом является то, что в языке Go строки сравни-
ваются побайтно, в соответствии с порядком сортировки символов
ASCII. И при сравнении строк, состоящих только из символов ниж-
него или верхнего регистра, будет получаться порядок сортировки,
более естественный для английского языка, как будет показано в
примере ниже (§4.2.4).

## 3.3. Символы и строки

Символы в языке Go могут быть представлены двумя разными
(но взаимозаменяемыми) способами. Единственный символ может
быть представлен значением типа rune (или int32 ). С этого момента
термины «символ», «кодовый пункт», «символ Юникода» и «кодо-
вый пункт Юникода» будут использоваться взаимозаменяемо для
ссылки на значение типа rune (или int32), хранящее единственный
символ. Строки в языке Go представлены последовательностями из
нуля или более символов – каждый символ внутри строки пред-
ставлен одним или более байт в кодировке UTF-8.

С помощью операции преобразования типа (string(символ)) един-
ственный символ можно преобразовать в односимвольную строку.
Например:

{% highlight go %}  
ìs := ""
for _, char := range []rune{‘ ì ’, 0xE6, 0346, 230, ‘\xE6’, ‘\u00E6’} {
	fmt.Printf("[0x%X ‘%c’] ", char, char)
	ìs += string(char)
}
{% endhighlight %}

Этот фрагмент выведет строку, в которой текст [0xE6 ‘ ì ’] по-
вторяется шесть раз, а после его выполнения переменная ì s будет
содержать строку, содержащую текст ìììììì . (Более эффектив-
ные альтернативы оператору += для использования в цикле будут
показаны чуть ниже.)

Преобразовать строку в срез со значениями типа rune (то есть ко-
довых пунктов) можно с помощью операции преобразования chars
:= []rune(s), где s – значение типа string. Значение chars в этом
случае будет иметь тип []int32, поскольку тип rune является сино-
нимом типа int32. Такая возможность может пригодиться, например,
когда потребуется выполнить посимвольный анализ строки и при
этом выбирать символы, стоящие перед и после текущего. Обратное
преобразование выполняется так же просто: s := string(chars), где
значение chars имеет тип []rune, или []int32, а значение s будет
иметь тип string. Оба преобразования имеют определенные наклад-
ные расходы, но выполняются достаточно быстро (имеют сложность
O(n), где n – количество байт; см. врезку «Нотация O(...)» ниже).
Дополнительные операции преобразования строк перечислены в
табл. 3.2 (выше), а преобразования «числоlстрока» – в табл. 3.8
и табл. 3.9 (ниже).

Несмотря на удобство, оператор += обеспечивает не самый эффек-
тивный способ наращивания строк в циклах. Более удачный способ
(хорошо знакомый программистам на Python) заключается в запол-
нении среза со строками ([]string) с последующим объединением
его элементов вызовом функции strings.Join(). Однако в языке Go
существует еще более эффективный путь , напоминающий исполь-
зование класса StringBuilder в языке Java. Например:

{% highlight go %}  
var buffer bytes.Buffer
for {
	if piece, ok := getNextValidString(); ok {
		buffer.WriteString(piece)
	} else {
		break
	}
}
fmt.Print(buffer.String(), "\n")
{% endhighlight %}

Фрагмент начинается с создания пустого значения типа bytes.
Buffer . Затем выполняется запись каждой строки в буфер с помо-
щью его метода bytes.Buffer.WriteString() . (При необходимости
можно было бы также организовать запись строки-разделителя меж-
ду фрагментами.) В конце вызывается метод bytes.Buffer.String() ,
извлекающий окончательную строку. (Особенности использования
мощного и гибкого типа bytes.Buffer будут показаны ниже.)

Прием накопления строки в bytes.Buffer потенциально более эф-
фективен с точки зрения вычислительных ресурсов и потребляемой
памяти, чем прием на основе оператора +=, особенно при большом
количестве объединяемых строк.

Цикл for ...range (§5.3) с успехом можно использовать для
итераций по символам строки. В этом случае в каждой итерации
программе становятся доступны индекс текущей позиции в строке
и кодовый пункт в этой позиции. Ниже приводятся пример исполь-
зования этой версии цикла и вывод, полученный в результате вы-
полнения данного фрагмента.