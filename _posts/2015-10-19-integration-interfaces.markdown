---
layout: post
title:  "6.3.1. Встраивание интерфейсов"
date:   2015-10-19 20:09:00
categories: go
---

Интерфейсы (и структуры, как будет показано в следующем разделе)
в языке Go обладают прекрасной поддержкой встраивания . Интер-
фейсы могут встраиваться в другие интерфейсы, что оказывает прак-
тически такой же эффект, как если бы сигнатуры методов во встра-
иваемом интерфейсе были объявлены в интерфейсе, куда он встраи-
вается. Эту особенность иллюстрирует следующий простой пример.


{% highlight go %}

type LowerCaser interface {
    LowerCase()
}
type UpperCaser interface {
    UpperCase()
}
type LowerUpperCaser interface {
    LowerCaser // Как если бы был объявлен метод LowerCase()
    UpperCaser // Как если бы был объявлен метод UpperCase()
}
{% endhighlight %}

Интерфейс LowerCaser определяет единственный метод
LowerCase(), не имеющий аргументов и ничего не возвращающий. Ин-
терфейс UpperCaser объявлен аналогично. Интерфейс LowerUpperCaser
встраивает два других интерфейса. То есть, чтобы конкретный тип
удовлетворял требованиям интерфейса LowerUpperCaser, он должен
иметь методы LowerCase() и UpperCase().

В этом коротком примере не видны все преимущества возможно-
сти встраивания интерфейсов. Однако, если в первые два интерфей-
са добавить дополнительные методы (например, LowerCaseSpecial()
и UpperCaseSpecial()), интерфейс LowerUpperCaser автоматически
включил бы их без изменения его определения.


{% highlight go %}

type FixCaser interface {
    FixCase()
}
type ChangeCaser interface {
    LowerUpperCaser // Как если бы были объявлены методы LowerCase() и UpperCase()
    FixCaser
    // Как если бы был объявлен метод FixCase()
}
{% endhighlight %}

Здесь были добавлены два новых интерфейса, и в результате по-
лучилась своеобразная иерархия встроенных интерфейсов, как по-
казано на рис. 6.2.

![Рис.6.2](/images/ris-6-2.jpg "Рис.6.2")


Интерфейсы сами по себе не используются – чтобы их задейство-
вать, они должны быть реализованы в конкретных типах.


{% highlight go %}
func (part *Part) FixCase() {
    part.Name = fixCase(part.Name)
}
{% endhighlight %}

Пользовательский тип Part уже был представлен выше. А
здесь в него был добавлен дополнительный метод FixCase(),
который воздействует на поле Name, подобно реализованным ра-
нее методам LowerCase() и UpperCase(). Все методы, изменяющие
регистр символов, требуют передачи приемника по указателю,
потому что изменяют само значение, относительно которого
вызываются. Методы LowerCase() и UpperCase() реализованы с
использованием функций из стандартной библиотеки, а метод
FixCase() опирается на пользовательскую функцию fixCase() –
такой прием, когда маленькие методы выполняют свою работу
с помощью функций, широко используется при программирова-
нии на языке Go.

Метод Part.String() (выше) реализует интерфейс fmt.Stringer из
стандартной библиотеки и гарантирует, что все значения типа Part
(или *Part) будут выводиться с использованием строки, возвраща-
емой этим методом.6.3. Интерфейсы
345


{% highlight go %}
func fixCase(s string) string {
    var chars []rune
    upper := true
    for _, char := range s {
        if upper {
            char = unicode.ToUpper(char)
        } else {
            char = unicode.ToLower(char)
        }
        chars = append(chars, char)
        upper = unicode.IsSpace(char) || unicode.Is(unicode.Hyphen, char)
    }
    return string(chars)
}
{% endhighlight %}



Эта простая функция возвращает копию переданной ей строки, где
все символы преобразованы в нижний регистр, кроме самого первого
и первых символов после пробелов или дефисов, которые преобра-
зуются в верхний регистр. Например, для исходной строки "lobelia
sackville-baggins" функция вернет "Lobelia Sackville-Baggins".
Естественно, поддержку всех представленных выше интерфейсов
можно реализовать в любом пользовательском типе.


{% highlight go %}
func (pair *StringPair) UpperCase() {
pair.first = strings.ToUpper(pair.first)
pair.second = strings.ToUpper(pair.second)
}
func (pair *StringPair) FixCase() {
pair.first = fixCase(pair.first)
pair.second = fixCase(pair.second)
}
{% endhighlight %}

Здесь в тип StringPair, созданный ранее, были добавлены мето-
ды, реализующие интерфейсы LowerCaser, UpperCaser и FixCaser, –
метод StringPair.LowerCase() не показан, потому что он по своей
структуре идентичен методу StringPair.UpperCase().

Оба типа, *Part и *StringPair, удовлетворяют требованиям всех рас-
сматриваемых интерфейсов, включая интерфейс ChangeCaser, потому
что он встраивает интерфейсы, уже реализуемые типом. Оба они так-
же реализуют интерфейс fmt.Stringer из стандартной библиотеки. А
тип *StringPair дополнительно реализует пользовательский интерфейс
Exchanger и интерфейс io.Reader из стандартной библиотеки.346


Нет необходимости включать реализацию всех интерфейсов, напри-
мер если отказаться от метода StringPair.FixCase(), тогда тип *StringPair
удовлетворял бы требованиям только интерфейсов LowerCaser,
UpperCaser, LowerUpperCaser, Exchanger, fmt.Stringer и io.Reader.
Создадим пару этих значений и посмотрим, как можно исполь-
зовать их методы.


{% highlight go %}
toastRack := Part{8427, "TOAST RACK"}
toastRack.LowerCase()
lobelia := StringPair{"LOBELIA", "SACKVILLE-BAGGINS"}
lobelia.FixCase()
fmt.Println(toastRack, lobelia)
"8427 "toast rack"" "Lobelia"+"Sackville-Baggins"
{% endhighlight %}

Методы вызываются и ведут себя, как и ожидалось. Но что, если име-
ется множество таких значений и требуется вызвать метод для каждого
из них? Ниже демонстрируется не самое лучшее решение этой задачи.


{% highlight go %}
for _, x := range []interface{}{&toastRack, &lobelia} { // НЕБЕЗОПАСНО!
x.(LowerUpperCaser).UpperCase() // Неконтролируемое приведение типа
}
{% endhighlight %}


Здесь необходимо использовать указатели на значения, потому
что все методы, изменяющие регистр символов, изменяют само зна-
чение, относительно которого вызываются, и потому требуют пере-
дачи приемников по указателю.
Подход, представленный в этом фрагменте, имеет два недостатка.
Меньший состоит в том, что в операции неконтролируемого при-
ведения типа используется интерфейс LowerUpperCaser, более обоб-
щенный, чем здесь требуется. Было бы хуже, если бы здесь исполь-
зовался еще более обобщенный интерфейс ChangeCaser. Но здесь
нельзя использовать интерфейс FixCaser, так как он определяет
только метод FixCase(). Лучше всего тут использовать минимально
необходимый интерфейс, в данном случае интерфейс UpperCaser. Са-
мый большой недостаток заключается в использовании именно не-
контролируемого приведения типов, поскольку эта операция может
возбудить аварийную ситуацию!


{% highlight go %}
for _, x := range []interface{}{&toastRack, &lobelia} {
    if x, ok := x.(LowerCaser); ok { // затеняющая переменная
    x.LowerCase()
}
{% endhighlight %}

В этом фрагменте реализовано более безопасное решение и ис-
пользуется самый специализированный интерфейс, но он выглядит
достаточно громоздко. Проблема – в использовании среза со значе-
ниями универсального типа interface{}, а не определенного типа
или типов, реализующих определенный интерфейс. Конечно, если
все, что доступно в данной точке программы, – это срез типа []
interface{}, тогда данное решение – лучшее, что можно сделать.



{% highlight go %}
    for _, x := range []FixCaser{&toastRack, &lobelia} { // Идеально
    x.FixCase()
}
{% endhighlight %}

Этот фрагмент иллюстрирует самое удачное решение: вме-
сто операции приведения типа для значений универсального ти-
па interface{} здесь срез определен как срез со значениями типа
FixCasers – наиболее специализированного интерфейса, достаточ-
ного для решения поставленной задачи, а все проверки типов пере-
кладываются на компилятор.

Еще одна гибкая особенность интерфейсов состоит в том, что
они могут создаваться по факту. Например, допустим, что в про-
грамме было создано несколько пользовательских типов, часть из
которых имеет метод IsValid() bool. Если позднее обнаружится,
что нужна некоторая функция, принимающая значение одного из
пользовательских типов и вызывающая метод IsValid(), если он
поддерживается значением, этого легко можно было бы добиться,
как показано ниже.

{% highlight go %}
type IsValider interface {
    IsValid() bool
}
{% endhighlight %}

Сначала нужно объявить интерфейс, определяющий методы, на-
личие которых требуется проверить.

{% highlight go %}
if thing, ok := x.(IsValider); ok {
    if !thing.IsValid() {
        reportInvalid(thing)
    } else {
        // ... обработать допустимое значение ...
    }
}
{% endhighlight %}


Имея интерфейс, можно легко проверить любое значение на на-
личие метода IsValid() bool и вызвать его.
Интерфейсы обеспечивают очень мощный механизм абстракции,
позволяющий определять множества методов так, чтобы в функциях
и методах можно было использовать параметры с типом интерфейса,
для которых интерес представляет лишь набор операций, которые
они поддерживают, а не их конкретные типы. Ниже в этой главе
будут представлены дополнительные примеры использования ин-
терфейсов (§6.5.2).

