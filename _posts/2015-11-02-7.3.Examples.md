---
layout: post
title:  "7.2.2. Пример: параллельный поиск"
date:   2015-11-02 22:00:00
categories: go
---

Одним из типичных шаблонов параллельного программирования
является разделение работы на множество заданий, каждое из ко-
торых может выполняться совершенно независимо. Например, на
основе этого шаблона в пакете net/http стандартной библиотеки
реализован HTTP-сервер, который обрабатывает каждый запрос
в отдельной go-подпрограмме, без взаимодействия с другими go-
подпрограммами. В этом подразделе будет представлен один из
возможных подходов к реализации данного шаблона на примере
программы cgrep (concurrent grep – параллельный поиск).

В отличие от HTTP-сервера из стандартной библиотеки, про-
грамма cgrep распределяет работу по фиксированному числу go-
подпрограмм, вместо того чтобы создавать их по мере необходимо-
сти. (Пример, использующий переменное число go-подпрограмм,
будет показан ниже, в §7.2.5.)

Программы cgrep принимают регулярное выражение и список
имен файлов в виде аргументов командной строки и для каждого
совпадения, найденного в файлах, выводят имя файла, номер стро-
ки и саму строку. Если совпадений не найдено, программа ничего
не выводит.

Программа cgrep1 (в файле cgrep1/cgrep.go) использует три ка-
нала, два из которых применяются для посылки и приема структур.

{% highlight go %}
type Job struct {
	filename string
	results chan<- Result
}
{% endhighlight %}

Эта структура определяет одно задание: имя файла и канал для
вывода результатов. Поле results можно было бы объявить как
results chan Result, но, так как при выполнении задания результаты
будут только посылаться и никогда не будут приниматься, канал
был объявлен однонаправленным, доступным только для посылки.


{% highlight go %}
type Result struct {
	filename string
	lino	int
	line	string
}
{% endhighlight %}

Каждый результат представлен значением этого составного типа
и содержит имя файла, номер строки (lino) и строку с найденным
совпадением.

{% highlight go %}
func main() {
	runtime.GOMAXPROCS(runtime.NumCPU()) // Использовать все доступные ядра
	if len(os.Args) < 3 || os.Args[1] == "-h" || os.Args[1] == "--help" {
		fmt.Printf("usage: %s <regexp> <files>\n", filepath.Base(os.Args[0]))
		os.Exit(1)
	}
	if lineRx, err := regexp.Compile(os.Args[1]); err != nil {
		log.Fatalf("invalid regexp: %s\n", err)
	} else {
		grep(lineRx, commandLineFiles(os.Args[2:]))
	}
}
{% endhighlight %}

Первая инструкция в функции main() сообщает окружению
времени выполнения языка Go о необходимости использовать все
процессоры (ядра), доступные в системе. Вызов функции runtime.
GOMAXPROCS(0) возвращает число процессоров и ничего не изменяет.
Вызов этой функции с положительным числом определяет коли-
чество процессоров, которые должно использовать окружение вре-
мени выполнения языка Go. Функция runtime.NumCPU() возвращает
количество логических процессоров/ядер, имеющихся в системе 1 .

Эту инструкцию можно добавлять в начало большинства парал-
лельных программ на языке Go, но со временем она станет из-
быточной, потому что окружение времени выполнения языка Go
сможет автоматически адаптироваться под компьютер, на котором
она выполняется.

Функция main() обрабатывает аргументы командной строки (ре-
гулярное выражение и список имен файлов) и вызывает функцию
grep() для выполнения работы, точнее для управления ею. (Функ-
ция commandLineFiles() была представлена в главе 4, в §4.4.2.)
Созданное здесь значение lineRx (типа *regexp.Regexp; §3.6.5)
передается функции grep() и в конечном счете совместно исполь-
зуется всеми рабочими go-подпрограммами. В общем случае по-
добное решение должно быть причиной для беспокойства, потому
что всегда следует исходить из того, что совместное использование
значений, передаваемых по указателю, небезопасно. В таких ситу-
ациях программист сам должен позаботиться о безопасности, на-
пример с помощью мьютексов. Как вариант можно пожертвовать
небольшим объемом памяти и вместо совместного использования
единственного значения создать отдельные значения для каждой go-
подпрограммы. К счастью, в данном конкретном случае докумен-
тация для языка Go явно утверждает, что значения типа *regexp.
Regexp поддерживают многопоточную модель выполнения. То есть
значение типа *regexp.Regexp может безопасно использоваться мно-
жеством go-подпрограмм.

{% highlight go %}
var workers = runtime.NumCPU()
func grep(lineRx *regexp.Regexp, filenames []string) {
	jobs := make(chan Job, workers)
	make(chan Result, minimum(1000, len(filenames)))
	results := make
	done := make(chan struct{}, workers)
	go addJobs(jobs, filenames, results) // Выполнить в собственной go-подпрограмме
	for i := 0; i < workers; i++ {	
		go doJobs(done, lineRx, jobs)		// Каждая в собственной go-подпрограмме
	}
	go awaitCompletion(done, results)	// Выполнить в собственной go-подпрограмме
	processResults(results)			// Заблокируется до конца работы
}
{% endhighlight %}

Эта функция создает три двунаправленных канала, необходимых
программе. Задания распределяются по рабочим go-подпрограммам,
количество которых соответствует количеству процессоров, поэто-
му, чтобы минимизировать ненужные задержки, каналы jobs и done
создаются буферизованными, с размерами буферов, равными этому
числу. (Конечно, легко можно было бы добавить параметр командной
строки, чтобы дать пользователю возможность определять количе-
ство рабочих go-подпрограмм независимо от числа процессоров.) Для
канала results используется значительно более емкий буфер, как это
было сделано в предыдущем подразделе, в примере filter, и исполь-
зуется функция minimum() (здесь не показана; см. §5.6.1.2, где приво-
дится одна из возможных реализаций, или исходный программный
код в файле cgrep.go, где находится реализация, используемая здесь).

Вместо того чтобы создать канал done типа chan bool и не беспо-
коиться о конкретном посылаемом значении, true или false, посколь-
ку значение имеет лишь факт посылки, здесь создается канал типа
chan struct{} (то есть пустая структура ), чтобы точнее выразить
семантику использования канала. В канал этого типа можно посылать
только пустые структуры (struct{}{}), только чтобы обозначить факт
посылки, значение которой не играет никакой роли.

После создания каналов вызывается функция addJobs(), добавля-
ющая задания в канал jobs. Эта функция выполняется в собственной
go-подпрограмме. Затем вызывается функция doJobs(), выполняю-
щая фактическую работу: в действительности функция вызывается
четыре раза, в результате чего запускаются четыре процесса обра-
ботки, каждый в своей go-подпрограмме. Затем вызывается функ-
ция awaitCompletion(), ожидающая, в собственной go-подпрограмме,
окончания выполнения всех заданий и затем закрывающая канал
results. Наконец, вызывается функция processResults(), выполня-
ющаяся в главной go-подпрограмме. Эта функция, обрабатывающая
результаты, принятые из канала results, блокируется до появления
результатов в канале и завершается, только когда будут приняты все
результаты. Структурная схема программы изображена на рис. 7.5.

!["Рис. 7.5. Множество независимых заданий, выполняющихся параллельно"](/images/ris-7-5.jpg "Рис. 7.5. Множество независимых заданий, выполняющихся параллельно")

{% highlight go %}
func addJobs(jobs chan<- Job, filenames []string, results chan<- Result) {
	for _, filename := range filenames {
		jobs <- Job{filename, results}
	}
	close(jobs)
}
{% endhighlight %}

Данная функция посылает имена файлов в канал jobs (по одно-
му) в составе значений типа Job. Канал jobs имеет буфер на четыре
элемента (по числу рабочих go-подпрограмм), поэтому первые че-
тыре задания будут посланы немедленно, а затем go-подпрограмма,
в которой выполняется функция, окажется заблокированной, в ожи-
дании, пока задание будет принято из канала и освободится место
для следующего. Когда все задания будут отправлены, что зависит
от количества имен файлов и скорости их обработки, канал jobs
будет закрыт.

Несмотря на то что два канала, которые передаются функции,
в действительности создаются как двунаправленные, в сигнатуре
функции они определяются как однонаправленные, доступные
только для посылки, потому что именно так канал jobs использу-
ется в функции и именно так канал Job.results объявлен в струк-
туре Job.

{% highlight go %}
func doJobs(done chan<- struct{}, lineRx *regexp.Regexp, jobs <-chan Job) {
	for job := range jobs {
		job.Do(lineRx)
	}
	done <- struct{}{}
}
{% endhighlight %}

Эта функция вызывается четыре раза, в четырех разных go-
подпрограммах, в результате создаются четыре процесса обработки
заданий. Каждый процесс выполняет итерации по элементам в об-
щем канале jobs (объявленном как доступный только для приема), и
каждый из них блокируется (точнее, блокируется go-подпрограмма,
в которой он выполняется), пока из канала не будет принято оче-
редное задание. Для выполнения каждого задания вызывается его
метод Job.Do() (который будет показан ниже). Когда все задания
будут выполнены, в канал done (объявленный как доступный только
для посылки) посылается пустая структура.

В соответствии с соглашениями, принятыми в языке Go, когда
принимает параметры с каналами, первыми в сигнатуре объявля-
ются каналы для вывода, а затем каналы для ввода.

{% highlight go %}
func awaitCompletion(done <-chan struct{}, struct results chan Result) {
	for i := 0; i < workers; i++ {
		<-done
	}
	close(results)
}
{% endhighlight %}

Эта функция (наряду с функцией processResults()) гарантиру-
ет, что главная go-подпрограмма продолжит выполняться, пока не
будут обработаны все задания, благодаря чему исключается вероят-
ность попадания в ловушку, упоминавшуюся в предыдущем разделе
(§7.1). Она выполняется в собственной go-подпрограмме и ожидает,
пока из канала done не будет принято требуемое количество посы-
лок по числу рабочих go-подпрограмм. Как только цикл завершится,
функция закроет канал results, чтобы известить принимающую сто-
рону, что результатов больше не будет. Обратите внимание, что здесь
канал results не был объявлен как доступный только для приема
(<-chan Result), потому что Go запрещает закрывать такие каналы.
Кроме того, функция не закрывает канал done, потому что он нигде
не проверяется на закрытие.

{% highlight go %}
func processResults(results <-chan Result) {
	for result := range results {
		fmt.Printf("%s:%d:%s\n", result.filename, result.lino, result.line)
	}
}
{% endhighlight %}

Эта функция выполняется в главной go-подпрограмме. Она вы-
полняет итерации по элементам в канале results или блокируется
в ожидании результатов. Как только все результаты будут приняты
и обработаны, цикл завершится, функция вернет управление, и про-
грамма закончит работу.

Поддержка параллельного выполнения в языке Go реализова-
на настолько гибко, что данный алгоритм – ожидание выполне-
ния заданий, закрытие каналов и вывод результатов – может быть
реализован различными способами. Например, программа cgrep2
(в файле cgrep2/cgrep.go), являющаяся разновидностью програм-
мы cgrep1, обсуждавшейся в этом подразделе, не имеет функций
awaitCompletion() или processResults() и вместо них использует
единственную функцию waitAndProcessResults().

{% highlight go %}
func waitAndProcessResults(done <-chan struct{}, results <-chan Result) {
	for working := workers; working > 0; {
		select { // Блокируется
			case result := <-results:
				fmt.Printf("%s:%d:%s\n", result.filename, result.lino, result.line)
			case <-done:
				working--
		}
	}
	DONE:
	for {
		select { // Не блокируется
			case result := <-results:
				fmt.Printf("%s:%d:%s\n", result.filename, result.lino, result.line)
			default:
				break DONE
		}
	}
}
{% endhighlight %}

Функция начинается с цикла for , который выполняется, пока су-
ществует хотя бы одна активная рабочая go-подпрограмма. Каждый
раз, когда в цикле for выполняется инструкция select, она блоки-
руется в ожидании приема из канала results или done. (Если здесь
использовать неблокирующую версию инструкции select , то есть с
разделом default, функция просто впустую будет расходовать про-
цессорное время.) Цикл for завершается, когда не остается ни одной
активной рабочей go-подпрограммы, то есть после того, как все ра-
бочие go-подпрограммы выполнят посылку значения в канал done.

После завершения всех рабочих go-подпрограмм начинает выпол-
няться второй цикл for. Внутри этого цикла используется небло-
кируемая инструкция select. Если в канале results имеются необ-
работанные результаты, выполняется первый раздел case, который
выводит результат, и выполнение цикла for продолжается. Так по-
вторяется, пока не будут выведены все необработанные результаты.
Как только выяснится, что в канале нет необработанных результатов
(что может произойти в первой же итерации, если к этому моменту
канал results был пуст), тут же выполняется переход к метке DONE.
(Простой инструкции break без метки недостаточно, так как она
прервет выполнение лишь инструкции select .) Этот второй цикл
не расходует процессорное время впустую, потому что в каждой
итерации либо будет выводиться очередной результат, либо цикл
будет прерываться, поэтому здесь нет необходимости останавливать
выполнение в ожидании очередного результата.

В данном примере функция waitAndProcessResults() получилась
длиннее и сложнее, чем оригинальные функции awaitCompletion()
и processResults(). Однако решение на основе инструкций select
может оказаться предпочтительнее, когда приходится обрабатывать
несколько разных каналов. Например, благодаря применению ин-
струкции select появляется возможность остановить обработку спу-
стя определенный промежуток времени, даже если к этому моменту
были обработаны не все результаты.
Ниже приводятся третья и последняя версия, cgrep3 (в файле
cgrep3/cgrep.go).

{% highlight go %}
func waitAndProcessResults(timeout int64, done <-chan struct{}, results <-chan Result) {
	finish := time.After(time.Duration(timeout))
	for working := workers; working > 0; {
		select { // Блокируется
			case result := <-results:
				fmt.Printf("%s:%d:%s\n", result.filename, result.lino,result.line)
			case <-finish:
				fmt.Println("timed out")
				return // Время вышло, поэтому завершить с уже имеющимися результатами
			case <-done:
				working--
		}
	}
	for {
		select { // Не блокируется
		case result := <-results:
			fmt.Printf("%s:%d:%s\n", result.filename, result.lino, result.line)
		case <-finish:
			fmt.Println("timed out")
			return // Время вышло, поэтому завершить с уже имеющимися результатами
		default:
			return
		}
	}
}
{% endhighlight %}

Это разновидность одноименной функции из примера cgrep2, от-
личающейся дополнительным параметром timeout. Функция time.
After() принимает значение time.Duration (фактически – число
наносекунд) и возвращает канал, в который она посылает текущее
время по истечении указанного интервала time.Duration. Здесь воз-
вращаемый ею канал присваивается переменной finish и в обе ин-
струкции select включается раздел для приема значения из этого
канала. По истечении установленного интервала времени (то есть
после посылки значения в канал finish) функция возвращает управ-
ление, и программа завершается, даже если работа еще не закончена.

Если все результаты будут собраны до истечения указанного интер-
вала времени (то есть все рабочие go-подпрограммы успеют закончить
работу), выполнение первого цикла for завершится, и начнется второй
цикл for, такой же, как в примере cgrep2. Единственное отличие здесь
заключается в том, что во второй инструкции select присутствует раз-
дел case для обработки канала finish и вместо прерывания второго
цикла for в разделе default просто выполняется возврат.

Теперь, когда было показано, как организовать параллельную об-
работку заданий, можно завершить обзор примеров cgrep знаком-
ством с методом, реализующим обработку одного задания.

{% highlight go %}
func (job Job) Do(lineRx *regexp.Regexp) {
	file, err := os.Open(job.filename)
	if err != nil {
		log.Printf("error: %s\n", err)
		return
	}
	defer file.Close()
	reader := bufio.NewReader(file)
	for lino := 1; ; lino++ {
		line, err := reader.ReadBytes(‘\n’)
		line = bytes.TrimRight(line, "\n\r")
		if lineRx.Match(line) {
			job.results <- Result{job.filename, lino, string(line)}
		}
		if err != nil {
			if err != io.EOF {
				log.Printf("error:%d: %s\n", lino, err)
			}
			break
		}
	}
}
{% endhighlight %}

Этот метод используется для обработки одного файла. Он по-
лучает указатель *regexp.Regexp , который, что вообще необычно
для указателей, безопасно можно использовать в многопоточном
окружении, поэтому не имеет никакого значения, как много go-
подпрограмм будут использовать его. Практически весь программ-
ный код в этом методе должен быть вам понятен: он открывает файл
для чтения, обрабатывает возможную ошибку и, если ошибка не воз-
никла, откладывает закрытие файла до завершения. Затем создает
буферизованное значение для чтения из файла, что упрощает ите-
рации по строкам. Всякий раз, когда обнаруживается совпадение с
регулярным выражением, в канал results посылается значение типа
Result: операция посылки будет блокироваться после заполнения
буфера канала. Для любого обрабатываемого файла может быть
произведено произвольное количество результатов, в том числе и
нуль, если ни в одной из строк не будет обнаружено совпадения с
регулярным выражением.

Как это принято в языке Go при работе с текстовыми файлами,
если при чтении строки возникла ошибка, она обрабатывается по-
сле обработки самой строки. Если метод bufio.Reader.ReadBytes()
столкнется с ошибкой (включая конец файла), он вернет байты, ко-
торые удалось прочесть до ошибки вместе с самой ошибкой. Ино-
гда последняя строка в файле не заканчивается символом перевода
строки, поэтому, чтобы гарантировать обработку последней стро-
ки в файле (не содержащей символ перевода строки), ошибка об-
рабатывается после обработки строки. Недостаток такого способа
обработки ошибок – в том, что если регулярное выражение может
совпасть с пустой строкой и будет получено не nil и не io.EOF зна-
чение ошибки, будет найдено ложное совпадение. (Разумеется, эту
ситуацию вполне можно обработать.)

Метод bufio.Reader.ReadBytes() возвращает байты, прочитанные
до указанного (включительно) байта (или до конца файла, если
указанный байт не будет встречен). Символ перевода строки здесь
не нужен, поэтому он удаляется вызовом метода bytes.TrimRight() ,
который удаляет указанный символ или символы с правого конца
строки. (Так же, как функция strings.TrimRight() ; см. табл. 3.7.)
Чтобы сделать программу кросс-платформенной, удаляются оба
символа, перевод строки и возврат каретки.

Обратите также внимание, что строки читаются как срезы с
байтами и сопоставление выполняется с помощью метода regexp.
Regexp.Match() , а не regexp.Regexp.MatchString(). Поэтому для совпа-
дающих строк необходимо выполнить (очень недорогое) преобразо-
вание значения типа []byte в значение типа string. Кроме того, для
удобства подсчет строк начинается с единицы, а не с нуля.

Особенно интересным аспектом архитектуры программы cgrep
являются простота и независимость организации параллельной об-
работки от фактической реализации выполнения заданий (в мето-
де Job.Do()), где единственным связующим звеном является канал
results. Такое разделение вообще характерно для параллельных
программ на языке Go и выглядит предпочтительнее, по сравнению
с использованием низкоуровневых конструкций (таких как мью-
тексы), где инструкции приобретения и освобождения блокировок
разбросаны по всей программе и могут загромождать и усложнять
логику работы программы.