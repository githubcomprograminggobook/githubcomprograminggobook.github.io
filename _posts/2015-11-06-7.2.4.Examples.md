---
layout: post
title:  "7.2.4. Пример: отчет о работе веб-сервера"
date:   2015-11-06 20:30:00
categories: go
---

* [7.2.4.1. Синхронизация с применением разделяемого поточно-ориентированного отображения](#section) 
* [7.2.4.2. Синхронизация с помощью мьютекса](#section-1)
* [7.2.4.3. Синхронизация объединением локальных отображений через каналы](#section-2)

Часто в программах, реализующих параллельную обработку данных,
возникает необходимость обновить некоторую совместно используемую структуру. Обычно для обеспечения очередности доступа
к такой структуре данных используются мьютексы. В языке Go в
подобных ситуациях можно использовать мьютексы или каналы. В
данном подразделе сначала будет продемонстрирован подход на основе каналов и поточно-ориентированного отображения, созданного
в предыдущем подразделе. Затем будет показан способ достижения
того же самого с помощью обычного отображения, доступ к которому защищен мьютексом. И наконец, будет представлен прием с использованием локальных независимых отображений, не требующих
разграничения доступа, позволяющий обеспечить максимальную
пропускную способность, и с использованием каналов, применяемых для обновления общего отображения в конце.

Все версии программы apachereport делают одно и то же: они
читают файл access.log, производимый веб-сервером Apache, и
выводят количество обращений к каждой HTML-странице, зафиксированных в этом файле журнала. Эти файлы журналов могут иметь
огромный размер, поэтому здесь будут использоваться несколько
go-подпрограмм: одна – для чтения строк из файла и три – для обработки строк. При первом обнаружении каждая HTML-страница
должна добавляться в отображение со значением счетчика, равным
1, и при каждом последующем обнаружении счетчик должен увеличиваться. То есть, несмотря на то что go-подпрограммы обрабатывают строки из файла журнала независимо друг от друга, все они
должны обновлять одно и то же отображение. Каждая версия программы использует свой способ обновления отображения.

## 7.2.4.1. Синхронизация с применением разделяемого поточно-ориентированного отображения

В этом подподразделе будет представлена программа apachereport1 (в
файле apachereport1/apachereport.go). Она использует поточно-ориентированное отображение, разработанное в предыдущем подразделе
в качестве совместно используемого отображения. Структура параллельной обработки в программе изображена на рис. 7.6.

!["Рис. 7.6. Множество взаимонезависимых заданий с синхронизацией результатов"](/images/ris-7-6.jpg "Рис. 7.6. Множество взаимонезависимых заданий с синхронизацией результатов")

На рис. 7.6 go-подпрограмма 2 используется для наполнения рабочего канала строками из файла журнала, а go-подпрограммы с 3
по 5 обрабатывают строки и обновляют отображение типа safeMap.
Непосредственные операции с отображением safeMap выполняются
в отдельной go-подпрограмме, то есть всего в программе используются шесть go-подпрограмм.

{% highlight go %}
var workers = runtime.NumCPU()

func main() {
    runtime.GOMAXPROCS(runtime.NumCPU()) // Use all the machine's cores
    if len(os.Args) != 2 || os.Args[1] == "-h" || os.Args[1] == "--help" {
        fmt.Printf("usage: %s <file.log>\n", filepath.Base(os.Args[0]))
        os.Exit(1)
    }
    lines := make(chan string, workers*4)
    done := make(chan struct{}, workers)
    pageMap := safemap.New()
    go readLines(os.Args[1], lines)
    processLines(done, pageMap, lines)
    waitUntil(done)
    showResults(pageMap)
}
{% endhighlight %}

Функция main() начинается с инструкции, сообщающей окружению времени выполнения языка Go о необходимости использовать
все доступные процессоры. Затем она создает два канала, необходимые для организации обработки. Канал lines используется для посылки строк из файла журнала, которые будут извлекаться рабочими go-подпрограммами. Каналу lines придается небольшой буфер,
чтобы уменьшить вероятность простоя рабочих go-подпрограмм в
ожидании поступления новых строк. Канал done используется для
слежения за завершением работы, и поскольку интерес здесь представляет лишь сам факт посылки в канал, в качестве значений для
этого канала используются пустые структуры. Канал done буферизован, чтобы не блокировать go-подпрограмм, желающих сообщить
о завершении работы.

Вслед за каналами создается новое значение неэкспортируемого типа safeMap, возвращаемое функцией safemap.New() в виде экспортируемого интерфейса SafeMap, который свободно может передаваться между функциями. Затем запускается go-подпрограмма
чтения строк из файлов и следом за ней – go-подпрограммы обработки строк. Затем функция ожидает завершения всех рабочих
go-подпрограмм и выводит результаты.

{% highlight go %}
func readLines(filename string, lines chan<- string) {
    file, err := os.Open(filename)
    if err != nil {
        log.Fatal("failed to open the file:", err)
    }
    defer file.Close()
    reader := bufio.NewReader(file)
    for {
        line, err := reader.ReadString('\n')
        if line != "" {
            lines <- line
        }
        if err != nil {
            if err != io.EOF {
                log.Println("failed to finish reading the file:", err)
            }
            break
        }
    }
    close(lines)
}
{% endhighlight %}

Эта функция очень похожа на функции, встречавшиеся выше.
Первая важная особенность – каждая строка посылается в канал
lines, доступный только для посылки, при этом, если буфер канала
полон, операция посылки блокируется, пока другая go-подпрограмма
не примет строку из канала. Естественно, заблокирована будет только данная go-подпрограмма, все остальные продолжат работу, как
ни в чем не бывало. Вторая важная особенность – после отправки
всех строк канал lines закрывается, чтобы известить предполагаемые принимающие go-подпрограммы об исчерпании данных. Однако имейте в виду, что данная go-подпрограмма выполняется параллельно с другими go-подпрограммами, в частности с рабочими go-подпрограммами, обрабатывающими строки, поэтому инструкция с
вызовом функции close() будет достигнута, только когда большая
часть работы будет уже выполнена.

{% highlight go %}
func processLines(done chan<- struct{}, pageMap safemap.SafeMap,
    lines <-chan string) {
    getRx := regexp.MustCompile(`GET[ \t]+([^ \t\n]+[.]html?)`)
    incrementer := func(value interface{}, found bool) interface{} {
        if found {
            return value.(int) + 1
        }
        return 1
    }
    for i := 0; i < workers; i++ {
        go func() {
            for line := range lines {
                if matches := getRx.FindStringSubmatch(line);
                    matches != nil {
                    pageMap.Update(matches[1], incrementer)
                }
            }
            done <- struct{}{}
        }()
    }
}
{% endhighlight %}

Эта функция следует соглашению о порядке следования аргументов, согласно которому первым следует канал вывода (в данном случае канал done), а затем канал ввода (в данном случае канал lines).

Функция создает go-подпрограммы (три в этом примере), выполняющие обработку строк. Каждая go-подпрограмма использует одно
и то же значение типа *regexp.Regexp (это значение в документации
описывается как допускающее возможность использования в многопоточном окружении, что в общем случае необычно для указателей)
и одну и ту же функцию incrementer() (так как она не имеет побочных эффектов и не обращается к совместно используемым данным).
Они также совместно используют одно и то же значение pageMap
(реализующее интерфейс SafeMap), поскольку даже методы, изменяющие фактическое значение, могут безопасно использоваться в
многопоточном окружении.

Функция regexp.Regexp.FindStringSubmatch() возвращает nil в
случае отсутствия совпадений или срез типа []string, первый элемент которого содержит совпадение со всем регулярным выражением, а каждый последующий – совпадения с соответствующими подвыражениями в круглых скобках. В данном случае имеется одно такое подвыражение, то есть при обнаружении совпадения срез будет
содержать точно два элемента: текст совпадения со всем регулярным
выражением и текст совпадения с подвыражением в круглых скобках, в данном случае – имя файла HTML-страницы.

Каждая go-подпрограмма принимает разные строки из канала lines, доступного только для приема, которые извлекаются из
файла go-подпрограммой, созданной в функции readLines(). Если
строка соответствует регулярному выражению, отыскивающему
GET-запросы к HTML-файлам, вызывается метод safeMap.Update()
с именем файла страницы (matches[1]) и функцией incrementer().
Функция incrementer() выполняется внутри go-подпрограммы поточно-ориентированного отображения. Она возвращает увеличенные значения счетчиков для существующих страниц и значение 1
для страниц, отсутствующих в отображении. (В предыдущем подразделе говорилось, что если функция, передаваемая методу safeMap.
Update(), попытается вызвать какой-либо другой метод интерфейса
SafeMap, возникнет состояние взаимоблокировки.) После обработки всех строк каждая рабочая go-подпрограмма посылает пустую
структуру в канал done, доступный только для посылки, чтобы сообщить о завершении работы.

{% highlight go %}
func waitUntil(done <-chan struct{}) {
    for i := 0; i < workers; i++ {
        <-done
    }
}
{% endhighlight %}

Эта функция выполняется в главной go-подпрограмме и блокируется в операции приема из канала done, доступного только для
приема. Когда все рабочие go-подпрограммы пошлют пустые структуры в канал done, цикл for завершится. Как обычно, здесь нет необходимости беспокоиться о закрытии канала done, потому что ни
одна функция в программе не проверяет его закрытие. Благодаря
блокировке в операции приема эта функция гарантирует, что обработка закончится до того, как завершится главная go-подпрограмма.

{% highlight go %}
func showResults(pageMap safemap.SafeMap) {
    pages := pageMap.Close()
    for page, count := range pages {
        fmt.Printf("%8d %s\n", count, page)
    }
}
{% endhighlight %}

Когда все строки будут прочитаны и все совпадения будут добавлены в отображение, будет вызвана эта функция для вывода результатов. Она начинается с вызова метода safemap.safeMap.
Close(), который закроет канал поточно-ориентированного отображения, завершит выполнение метода safeMap.run() в отдельной go-подпрограмме и вернет фактическое отображение типа map[string]
interface{}. После этого полученное отображение будет недоступно
через канал поточно-ориентированного отображения и потому безопасно может использоваться в единственной go-подпрограмме (или
в нескольких подпрограммах, если обеспечить очередность операций
с помощью мьютекса). С этого момента доступ к отображению имеет
только главная go-подпрограмма, поэтому разграничивать доступ к
нему не требуется. Здесь просто выполняются итерации по парам
ключ/значение отображения и осуществляется их вывод в консоль.

Использование значения, реализующего интерфейс SafeMap, обеспечивает безопасность, простоту синтаксиса и устраняет необходимость применения блокировок. Один из недостатков такого подхода – в том, что значения в поточно-ориентированном отображении
имеют тип обобщенного интерфейса interface{}, а не конкретный
тип, чем обусловлена необходимость использовать операцию приведения типа в функции incrementer(). (Ниже, в §7.2.4.3, будет рассказано еще об одном недостатке.)


## 7.2.4.2. Синхронизация с помощью мьютекса

Теперь сравним и сопоставим простой и понятный подход на основе
каналов с традиционным подходом на основе мьютексов. Для этого
коротко рассмотрим программу apachereport2 (в файле apachereport2/
apachereport.go). Она представляет собой версию программы
apachereport1, использующей пользовательский тип данных, инкапсулирующий отображение и мьютекс. Эти две программы выполняют
одну и ту же работу, но по-разному. Программа apachereport2 хранит
в своем отображении целочисленные значения, а не значения типа
interface{}, как поточно-ориентированное отображение, реализующее интерфейс SafeMap. Кроме того, упомянутый пользовательский
тип предоставляет минимальный объем функциональных возможностей, только те, что необходимы для выполнения работы (метод
Increment()), в противовес поточно-ориентированному отображению,
реализующему законченный набор методов.

{% highlight go %}
type pageMap struct {
    countForPage map[string]int
    mutex        *sync.RWMutex
}
{% endhighlight %}

Одно из преимуществ использования конкретного типа данных
заключается в отсутствии необходимости использовать обобщенный
тип interface{}.

{% highlight go %}
func NewPageMap() *pageMap {
    return &pageMap{make(map[string]int), new(sync.RWMutex)}
}
{% endhighlight %}

Эта функция возвращает готовое к использованию значение типа
*pageMap. (В данном случае можно было бы создать указатель на
мьютекс, использовав выражение &sync.RWMutex{} вместо new(sync.
RWMutex) ; эквивалентность подобных выражений обсуждалась в §4.1.)

{% highlight go %}
func (pm *pageMap) Increment(page string) {
    pm.mutex.Lock()
    defer pm.mutex.Unlock()
    pm.countForPage[page]++
}
{% endhighlight %}

Каждый метод, изменяющий отображение countForPage, должен
разграничивать доступ к нему с помощью мьютекса. Здесь используется канонический шаблон: запереть мьютекс, отложить его отпирание до завершения функции (отпирание гарантируется даже в случае аварийной ситуации) и выполнить операцию доступа – в идеале
выполняющуюся как можно более короткий промежуток времени.

Благодаря механизму автоматической инициализации переменных нулевыми значениями при первом обращении к странице в
отображении countForPage (то есть когда она еще не включена в
отображение) она будет добавлена в отображение со значением 0,
которое немедленно будет увеличено на единицу. Соответственно,
при последующих обращениях к странице, уже имеющейся в отображении, увеличиваться будет ранее сохраненное значение.

Каждый метод, обращающийся к отображению countForPage, должен разграничивать доступ к нему с помощью мьютекса. Для обновления значений в отображении необходимо использовать методы sync.
RWMutex.Lock() и sync.RWMutex.Unlock() , как показано выше, но при
обращении только для чтения можно использовать другие методы.

{% highlight go %}
func (pm *pageMap) Len() int {
    pm.mutex.RLock()
    defer pm.mutex.RUnlock()
    return len(pm.countForPage)
}
{% endhighlight %}

Этот метод включен в пример, только чтобы показать, как использовать блокировки для чтения. Здесь используется тот же шаблон,
но блокировки для чтения потенциально более эффективны (потому
что, используя их, мы сообщаем, что собираемся только читать защищенный ресурс, но не изменять его). Например, если имеются
несколько go-подпрограмм, читающих значения из одного и того
же отображения countForPage, они безопасно могут выполнять операции чтения параллельно, используя блокировку для чтения. Но
если хотя бы одна из них приобретет обычную (для чтения и записи) блокировку и, следовательно, способность изменять содержимое
отображения, никакая другая блокировка не сможет быть приобретена на это время.

{% highlight go %}
pageMap.Increment(matches[1])
{% endhighlight %}

После создания отображения типа pageMap рабочие go-подпрограммы смогут обновлять его с помощью этой инструкции.


## 7.2.4.3. Синхронизация объединением локальных отображений через каналы

Используя поточно-ориентированное отображение или простое отображение, защищенное мьютексом, оправданно было бы ожидать,
что увеличение количества рабочих go-подпрограмм приведет к
увеличению общей скорости работы программы. Однако, поскольку
операции доступа к отображениям выполняются поочередно (неявно, при использовании поточно-ориентированного отображения), с
увеличением количества go-подпрограмм будет нарастать и их конкуренция за обладание ресурсом.

Как это часто бывает, добиться увеличения скорости можно за
счет увеличения потребления памяти. Например, в каждой go-подпрограмме можно было бы создать собственное простое отображение. Это позволило бы увеличить пропускную способность
благодаря полному отсутствию конкуренции, но ценой увеличения
потребления памяти (поскольку во всех отображениях наверняка
будет храниться информация об одних и тех же страницах). В конце эти отображения потребовалось бы объединить, и это стало бы
узким местом в программе, потому что, пока выполняется объединение одного отображения, все остальные вынуждены будут ждать
своей очереди.

Программа apachereport3 (в файле apachereport3/apachereport.
go) использует локальные отображения и в конце объединяет
их в общее отображение. Эта программа практически идентична
программам apachereport1 и apachereport2, поэтому далее будут рассматриваться лишь ключевые отличия. Структура параллельной обработки в программе изображена на рис. 7.7.

!["Рис. 7.7. Множество взаимозависимых заданий с синхронизацией результатов"](/images/ris-7-7.jpg "Рис. 7.7. Множество взаимозависимых заданий с синхронизацией результатов")


{% highlight go %}
func main() {
    runtime.GOMAXPROCS(runtime.NumCPU()) // Use all the machine's cores
    if len(os.Args) != 2 || os.Args[1] == "-h" || os.Args[1] == "--help" {
        fmt.Printf("usage: %s <file.log>\n", filepath.Base(os.Args[0]))
        os.Exit(1)
    }
    lines := make(chan string, workers*4)
    results := make(chan map[string]int, workers)
    go readLines(os.Args[1], lines)
    getRx := regexp.MustCompile(`GET[ \t]+([^ \t\n]+[.]html?)`)
    for i := 0; i < workers; i++ {
        go processLines(results, getRx, lines)
    }
    totalForPage := make(map[string]int)
    merge(results, totalForPage)
    showResults(totalForPage)
}
{% endhighlight %}

Это фрагмент из функции main() программы apachereport3. Вместо канала done здесь используется канал results, посредством которого рабочие go-подпрограммы посылают локальные отображения
после их заполнения. Здесь также создается общее отображение
(totalForPage), куда объединяются все результаты.

{% highlight go %}
func processLines(results chan<- map[string]int, getRx *regexp.Regexp,
    lines <-chan string) {
    countForPage := make(map[string]int)
    for line := range lines {
        if matches := getRx.FindStringSubmatch(line); matches != nil {
            countForPage[matches[1]]++
        }
    }
    results <- countForPage
}
{% endhighlight %}

Эта функция практически идентична предыдущей версии. Она
имеет следующие ключевые отличия: во-первых, для хранения счетчиков обращений к страницам в каждой go-подпрограмме создается локальное отображение, и, во-вторых, по завершении обработки
строк вместо посылки пустой структуры struct{}{} в канал done
функция посылает локальное отображение в канал results.

{% highlight go %}
func merge(results <-chan map[string]int, totalForPage map[string]int) {
    for i := 0; i < workers; i++ {
        countForPage := <-results
        for page, count := range countForPage {
            totalForPage[page] += count
        }
    }
}
{% endhighlight %}

По своей структуре эта функция идентична функции waitUntil(),
представленной выше, но на этот раз принятое значение используется
для обновления содержимого общего отображения totalForPage. Обратите внимание, что после отправки отображений go-подпрограммы
больше не обращаются к ним, благодаря чему отпадает необходимость
использования блокировок.

Функция showResults() почти не изменилась (поэтому она здесь
не показана). Единственное ее отличие состоит в том, что она принимает отображение totalForPage в виде аргумента и выполняет итерации по этому отображению, выводя страницы и счетчики.

Реализация программы apachereport3 выглядит проще и понятнее, по сравнению с программами apachereport1 и apachereport2,
и модель параллельной обработки, когда каждая go-подпрограмма
заполняет собственную локальную структуру данных, с объединением их в конце, с успехом может использоваться в самых разных
контекстах.

Конечно, для программистов, привыкших использовать парадигму блокировок, вполне естественно попробовать в программах на
языке Go использовать мьютексы для разграничения доступа. Однако документация к языку Go настоятельно рекомендует использовать go-подпрограммы и каналы и повторять мантру: «не взаимодействовать, разделяя память, а разделять память, взаимодействуя»,
да и компиляторы Go оптимизированы в первую очередь для поддержания именно этой модели параллельной обработки.