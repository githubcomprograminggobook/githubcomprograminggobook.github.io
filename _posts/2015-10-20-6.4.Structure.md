---
layout: post
title:  "6.4. Структуры"
date:   2015-10-20 15:06:00
categories: go
---

Простейшие пользовательские типы в программах на языке Go осно-
вываются на встроенных типах, например инструкция type Integer
int создаст пользовательский тип Integer, к которому можно будет
добавить собственные методы. Пользовательские типы могут также
создаваться на основе структур, используемых для агрегирования и
встраивания значений. Это особенно удобно, когда эти значения, на-
зываемые полями, имеют разные типы и не могут храниться в общем
срезе (если только не использовать срез типа []interface{}). Струк-
туры в языке Go ближе к структурам в языке C, чем в C++ (напри-
мер, они не являются классами), но более удобны в использовании
благодаря отличной поддержке встраивания.

В предыдущих главах и в этой главе приводилось немало при-
меров структур, и еще много их встретится в оставшейся части
книги. Тем не менее некоторые особенности структур еще не были
описаны, поэтому для начала рассмотрим несколько примеров, де-
монстрирующих их.

{% highlight perl %}  
points := [][2]int{{'{{'|escape}}4, 6}, {}, {-7, 11}, {15, 17}, {14, -8}}
for _, point := range points {
	fmt.Printf("(%d, %d) ", point[0], point[1])
}
{% endhighlight %}

Переменная points во фрагменте выше – это срез с массивами
типа [2]int, поэтому для получения каждой координаты приходит-
ся использовать оператор индексирования []. (Элемент {} – это то
же самое, что и {0, 0}, благодаря автоматической инициализации
переменных в языке Go.) Такой подход вполне пригоден для не-
больших объемов простых данных, но существует более удобный
способ реализовать то же самое – с помощью анонимной структуры .

{% highlight go %}
points := []struct{ x, y int }{{'{{'|escape}}4, 6}, {}, {-7, 11}, {15, 17}, {14, -8}}
for _, point := range points {
	fmt.Printf("(%d, %d) ", point.x, point.y)
}
{% endhighlight %}

Переменная points в данном – это срез со структурами struct{x, y int} . 
Несмотря на то что сама структура не имеет имени, в
программном коде можно обращаться к ее полям по их именам, что
гораздо проще, чем использовать массивы и индексы.


## 6.4.1. Структуры: агрегирование и встраивание

Структуры поддерживают такую же возможность встраивания , как
интерфейсы или другие типы, то есть они могут включаться в дру-
гие структуры в виде поля, состоящего только из имени структуры.
(Разумеется, если такому полю дать имя, получится агрегированное
именованное поле, а не встроенное анонимное.)

Поля встроенного поля обычно доступны непосредственно, с по-
мощью оператора точки (. ), без упоминания имени типа, но если
вмещающая структура имеет поле с тем же именем, что и поле во
встроенной структуре, тогда необходимо использовать имя типа
встроенной структуры, чтобы устранить неоднозначность.

Имена полей в структуре должны быть уникальными. К встро-
енным (то есть анонимным) полям предъявляются особенно стро-
гие требования уникальности. Например, если в структуре имеется
встроенное поле типа Integer, в нее также можно добавить другие
поля с именами, например Integer2 или BigInteger, поскольку они
отчетливо различимы. Но в эту структуру уже нельзя будет доба-
вить поле с именем, например, Matrix.Integer или *Integer, потому
что уникальность полей определяется по последним компонентам
в их именах, а последние компоненты в них совпадают с именем
встроенного поля Integer.


### 6.4.1.1. Встраивание значений

Начнем с изучения простого примера двух структур.

{% highlight go %}
type Person struct {
	Title
	string // Именованное поле(агрегирование)
	Forenames []string // Именованное поле(агрегирование)
	Surname string // Именованное поле(агрегирование)
}
type Author1
	Names		// Именованное поле(агрегирование)
	Title		// Именованное поле(агрегирование)
	YearBorn	// Именованное поле(агрегирование)
}
{% endhighlight %}

В предыдущих главах демонстрировалось множество похожих
примеров. Здесь все поля в структуре Author1 имеют имена. Ниже
показано, как можно использовать эти структуры и что выводится
(благодаря наличию метода Author1.String(), который здесь не по-
казан).

{% highlight go %}
author1 := Author1{Person{"Mr", []string{"Robert", "Louis", "Balfour"}, "Stevenson"}, []string{"Kidnapped", "Treasure Island"}, 1850}
fmt.Println(author1)
author1.Names.Title = ""
author1.Names.Forenames = []string{"Oscar", "Fingal", "O’Flahertie", "Wills"}
author1.Names.Surname = "Wilde"
author1.Title = []string{"The Picture of Dorian Gray"}
author1.YearBorn += 4
fmt.Println(author1)
__________________
Stevenson, Robert Louis Balfour, Mr (1850) "Kidnapped" "Treasure Island"
Wilde, Oscar Fingal O’Flahertie Wills (1854) "The Picture of Dorian Gray"
{% endhighlight %}

Здесь сначала создается значение типа Author1, затем по порядку
заполняются все его поля, и, наконец, это значение выводится. Далее поля структуры изменяются, и она снова выводится в консоль.

{% highlight go %}
type Author2 struct {
	Person	 	// Анонимное поле(встраивание)
	Title []string 	// Именованное поле(агрегирование)
	YearBorn int 	// Именованное поле(агрегирование)
}
{% endhighlight %}

Для встраивания анонимного поля используется имя типа (или
интерфейса, как будет показано ниже) без определения имени поля.
Обращаться к полям в этом поле можно непосредственно (то есть
без указания имени типа или интерфейса) или используя имя типа
или интерфейса, если это необходимо для устранения неоднознач-
ности, при наличии одноименных полей во вмещающей структуре.

Структура Author2 встраивает структуру Person как анонимное по-
ле. Это означает, что к полям структуры Person можно обращаться
непосредственно (за исключением случаев, когда необходимо избе-
жать неоднозначности).

{% highlight go %}
author2 := Author2{Person{"Mr", []string{"Robert", "Louis", "Balfour"}, "Stevenson"}, []string{"Kidnapped", "Treasure Island"}, 1850}
fmt.Println(author2)
author2.Title = []string{"The Picture of Dorian Gray"}
author2.Person.Title = "" // Имя типа используется для устранения неоднозначности
author2.Forenames = []string{"Oscar", "Fingal", "O’Flahertie", "Wills"}
author2.Surname = "Wilde" // То же, что и: author2.Person.Surname = "Wilde"
author2.YearBorn += 4
fmt.Println(author2)
{% endhighlight %}

В этом фрагменте повторяется программный код, где использова-
лась структура Author1, но на этот раз в нем используется структура
Author2. Он производит идентичный вывод (предполагается наличие
метода Author2.String(), возвращающего то же строковое значение,
что и метод Author1.String()).

За счет встраивания структуры Person в виде анонимного поля
удалось получить практически тот же эффект, как при непосред-
ственном добавлении полей структуры Person, но не совсем, пото-
му что при непосредственном добавлении полей в окончательной
структуре получилось бы два поля Title, что привело бы к ошибке
во время компиляции.

Значение типа Author2 создается точно так же, как значение типа
Author1, но на этот раз к полям структуры Person можно обращать-
ся непосредственно (например, author2.Forenames), за исключени-
ем случаев, когда требуется избежать неоднозначности (author2.
Person.Title вместо author2.Title).


### 6.4.1.2. Встраивание анонимных значений с методами

Если встроенное поле обладает методами , их можно вызывать от-
носительно вмещающей структуры, но в качестве приемников таким
методам будет передаваться анонимное поле.

{% highlight go %}
type Tasks struct {
	slice []string // Именованное поле (агрегирование)
	Count	// Анонимное поле (встраивание)
}
func (tasks *Tasks) Add(task string) {
	tasks.slice = append(tasks.slice, task)
	tasks.Increment() // то же, что и: tasks.Count.Increment()
}
func (tasks *Tasks) Tally() int {
	return int(tasks.Count)
}
{% endhighlight %}

Определение типа Count было показано выше (§6.2.1). Структура
Tasks имеет два поля: агрегированный срез со строками и встроен-
ное значение Count. Как видно в реализации метода Tasks.Add(), к
методам анонимного поля типа Count можно обращаться непосред-
ственно.

{% highlight go %}
tasks := Tasks{}
fmt.Println(tasks.IsZero(), tasks.Tally(), tasks)
tasks.Add("One")
tasks.Add("Two")
fmt.Println(tasks.IsZero(), tasks.Tally(), tasks)
true 0 {[] 0}
false 2 {[One Two] 2}
{% endhighlight %}

Здесь создается значение типа Tasks и вызываются его методы
Tasks.Add(), Tasks.Tally() и Tasks.Count.IsZero() (как Tasks.IsZe-
ro()). Даже при том, что этот тип не имеет собственного метода
Tasks.String(), функции вывода, имеющиеся в языке Go, воспроиз-
водят вполне понятный вывод при попытке вывести значение Tasks.
(Обратите внимание, что вызов метода Count() для структуры Tasks,
если бы он имелся, не был бы скомпилирован, потому что это вы-
звало бы конфликт имен со встроенным значением Tasks.Count.)

При вызове метода встроенного поля важно помнить, что в ка-
честве приемника методу передается само встроенное поле. То есть
при вызове Tasks.IsZero(), Tasks.Increment() и других методов типа
Count относительно значения типа Tasks этим методам передается
значение типа Count (или *Count), а не Tasks.

В этом примере тип Tasks имеет собственные методы (Add() и
Tally()), а также методы встроенного поля типа Count (Increment(),
Decrement() и IsZero()). Конечно, в типе Tasks можно переопреде-
лить любые или даже все методы типа Count, просто реализовав
методы с теми же именами. (Подобный пример был представлен
выше, §6.2.1.1.)

### 6.4.1.3. Встраивание интерфейсов

Помимо агрегирования и встраивания в структуры конкретных типов,
имеется также возможность агрегирования и встраивания интерфей-
сов. (Естественно, обратное – агрегирование и встраивание структур
в интерфейсы – невозможно, потому что интерфейс является полно-
стью абстрактным типом, то есть такое агрегирование и встраивание
является сущей бессмыслицей.) Когда структура включает агреги-
рованное (именованное) или встроенное (анонимное) поле с типом
интерфейса, это означает, что структура может хранить в таком поле
любое значение, реализующее методы указанного интерфейса.

Закончим обсуждение структур простым примером, демонстри-
рующим, как можно организовать поддержку параметров команд-
ной строки, имеющих короткие и длинные имена (например, «-o"
и "--outfile") и принимающих значения определенных типов (int,
float64, string), а также некоторых общих методов. (Этот пример
создавался в учебных целях, а потому не блещет элегантностью.
Полнофункциональный инструмент для работы с параметрами ко-
мандной строки можно найти в стандартной библиотеке, в виде
пакета flag, или в виде сторонних пакетов на сайте godashboard.
appspot.com/project.)

{% highlight go %}
type Optioner interface {
	Name()
	string
	IsValid() bool
}
type OptionCommon struct {
	ShortName string "short option name"
	LongName string "long option name"
}
{% endhighlight %}

Интерфейс Optioner определяет общие методы для всех типов па-
раметров, поддержку которых требуется реализовать. Структура Op-
tionCommon имеет два поля, общих для всех параметров. В языке Go
имеется возможность снабжать поля структур строковыми приме-
чаниями (в терминологии Go они называются тегами ). Эти теги не
имеют функционального назначения, но, в отличие от комментариев,
они доступны с применением механизма рефлексии (§9.4.9). Неко-
торые программисты используют теги для нужд проверки допусти-
мости значений полей, например определив тег "check:len(2,30)"
для строки или тег "check:range(0,500)" для числа и дополнитель-
ную семантику в программе.

{% highlight go %}
type IntOption struct {
	OptionCommon		// Анонимное поле (встраивание)
	Value, Min, Max int // именованное поле (агрегирование)
}
func (option IntOption) Name() string {
	return name(option.ShortName, option.LongName)
}
func (option IntOption) IsValid() bool {
	return option.Min <= option.Value && option.Value <= option.Max
}
func name(shortName, longName string) string {
	if longName == "" {
		return shortName
	}
	return longName
}
{% endhighlight %}

Это законченная реализация типа IntOption и неэкспортируемой
функции name(). Благодаря встраиванию структуры OptionCommon по-
является возможность обращаться к ее полям непосредственно, как
это делается в методе IntOption.Name(). Структура IntOption удов-
летворяет требованиям интерфейса Optioner (поскольку предостав-
ляет методы Name() и IsValid() с требуемыми сигнатурами).

Несмотря на простоту функции name(), было принято реализо-
вать обработку именно в отдельной функции, а не внутри метода
IntOption.Name(). Это делает метод IntOption.Name() очень корот-
ким и дает возможность повторно использовать данную функцию
в других типах параметров. Так, например, тела методов Generi-
cOption.Name() и StringOption.Name() совершенно идентичны телу
метода IntOption.Name() и состоят из единственной инструкции,
при этом все три метода для выполнения фактической работы вы-
зывают функцию name(). Это типичный шаблон программирования
на языке Go, и он снова будет использован в последнем разделе
этой главы.

Реализация структуры StringOption очень похожа на реализацию
структуры IntOption, поэтому здесь она не показана. (Различия за-
ключаются только в поле Value, имеющем тип string, и в методе
IsValid(), возвращающем true, если поле Value содержит непустое
значение.) При реализации структуры FloatOption был использован
прием встраивания интерфейса, только чтобы показать, как это де-
лается.

{% highlight go %}
type FloatOption struct {
	Optioner 	// Анонимное поле (встраивание интерфейса: требует конкретный тип)
	Value float64 // Именованное поле (агрегирование)
}
{% endhighlight %}

Это законченная реализация структуры FloatOption. Встроенное
поле Optioner означает, что при создании значений типа FloatOption
встроенному полю должно присваиваться значение, удовлетворяю-
щее требованиям интерфейса Optioner.

{% highlight go %}
type GenericOption struct {
	OptionCommon // Анонимное поле (встраивание)
}
func (option GenericOption) Name() string {
	return name(option.ShortName, option.LongName)
}
func (option GenericOption) IsValid() bool {
	return true
}
{% endhighlight %}

Это законченная реализация структуры GenericOption – типа,
удовлетворяющего требованиям интерфейса Optioner.

Тип FloatOption имеет встроенное поле типа Optioner, поэтому
для него требуется указывать значение конкретного типа, реализу-
ющего интерфейс Optioner. Это требование можно удовлетворить
присваиванием полю Optioner в структуре FloatOption значения
типа GenericOption.

Теперь, когда в наличии имеются все фрагменты мозаики (IntOption,
FloatOption и др.), посмотрим, как создавать и использовать значения
этих типов.

{% highlight go %}
fileOption := StringOption{OptionCommon{"f", "file"}, "index.html"}
topOption := IntOption{
	OptionCommon: OptionCommon{"t", "top"},
	Max: 100,
}
sizeOption := FloatOption{ GenericOption{ OptionCommon{ "s", "size"}}, 19.5}
for _, option := range []Optioner{topOption, fileOption, sizeOption} {
	fmt.Print("name=", option.Name(), " • valid=", option.IsValid())
	fmt.Print(" • value=")
	switch option := option.(type) { // затеняющая переменная
		case IntOption:
			fmt.Print(option.Value, " • min=", option.Min, " • max=", option.Max, "\n")
		case StringOption:
			fmt.Println(option.Value)
		case FloatOption:
			fmt.Println(option.Value)
	}
}
name=top • valid=true • value=0 • min=0 • max=100
name=file • valid=true • value=index.html
name=size • valid=true • value=19.5
{% endhighlight %}

Вначале создается переменная fileOption типа StringOption, каж-
дому полю которой присваивается соответствующее значение. Но в
переменной topOption типа IntOption присвоить значение необходи-
мо только полям OptionCommon и Max, потому что для других полей
(Value и Min) прекрасно подходят нулевые значения. В языке Go
допускается создавать структуры и инициализировать лишь отдель-
ные поля, используя синтаксис имяПоля: значениеПоля. В этом случае
всем полям, не инициализированным явно, автоматически присваи-
ваются соответствующие нулевые значения.

Первым полем в значении sizeOption типа FloatOption является
интерфейс Optioner, поэтому ему следует присвоить значение кон-
кретного типа, удовлетворяющего требованиям этого интерфейса.
Здесь для этой цели создано значение типа GenericOption.

Создав три разных параметра, по ним можно выполнить итера-
ции, используя срез типа []Optioner, то есть срез со значениями,
удовлетворяющими требованиям интерфейса Optioner. Внутри цик-
ла переменной option по очереди присваивается каждый параметр
(типа Optioner). Относительно переменной option можно вызывать
любые методы, определяемые интерфейсом Optioner, как это сде-
лано в теле цикла, где вызываются методы Option.Name() и Option.
IsValid().

Каждый тип параметров имеет поле Value, но все они имеют
разные типы, например поле IntOption.Value имеет тип int, а поле
StringOption.Value – тип string. Поэтому для доступа к конкретным
полям Value (и аналогично к любым другим полям или методам, име-
ющим определенный тип), необходимо преобразовать текущее зна-
чение option в значение конкретного типа. Это легко достигается с
помощью инструкции switch выбора по типу (§5.2.2.2). В выражении
переключателя типа используется затеняющая переменная (option),
которая всегда будет иметь правильный тип для выполняемой ин-
струкции case (например, в инструкции case IntOption переменная
option будет иметь тип IntOption и т. д.). Поэтому в каждой ветке
case можно смело обращаться к любым полям и методам с учетом
их фактических типов.