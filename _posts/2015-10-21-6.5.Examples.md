---
layout: post
title:  "6.5. Примеры"
date:   2015-10-21 13:33:00
categories: go
---

* [6.5.1. Пример: FuzzyBool – пользовательский тип с единственным значением](#fuzzybool------) 
* [6.5.2. Пример: фигуры – семейство пользовательских типов](#section)
* [6.5.2.1. Вспомогательные функции](#section-1)
* [6.5.2.2. Иерархия встроенных интерфейсов](#section-2)
* [6.5.2.3. Свободно компонуемые независимые интерфейсы](#section-3)
* [6.5.2.4. Конкретные типы и методы](#section-4)

Теперь, когда стало понятно, как создавать собственные типы, мож-
но перейти к знакомству с более практичными примерами. Первый
пример демонстрирует, как создать простой тип значения. Второй
пример демонстрирует, как создать множество взаимосвязанных ин-
терфейсов и структур с применением приема встраивания и как ре-
ализовать не только функции-конструкторы, но и фабричные функ-
ции , чтобы обеспечить возможность создания значений всех типов,
экспортируемых пакетом. Третий пример демонстрирует порядок
реализации законченного универсального типа коллекций.


## 6.5.1. Пример: FuzzyBool – пользовательский тип с единственным значением

В этом разделе будет показано, как создать пользовательский тип
с единственным значением и его методы. Этот пример находится в
файле fuzzy/fuzzybool/fuzzybool.go и основан на структуре.

Встроенный тип bool имеет два возможных значения (true и
false), но в некоторых системах искусственного интеллекта ис-
пользуется нечеткая логика. Логические величины в таких системах
могут иметь не только значения «истина» или «ложь», но также зна-
чения, занимающие промежуточные положения. В данной реализа-
ции для представления логических значений будут использоваться
вещественные числа: 0.0 – для значения false и 1.0 – для значения
true. В данной реализации значение 0.5 означает 50% истины (50%
лжи), значение 0.25 означает 25% истины (75% лжи) и т. д. Ниже
приводятся несколько примеров использования такого типа.


{% highlight go %}  
func main() {
	a, _ := fuzzybool.New(0)   // Значение ошибки можно смело игнорировать при
	b, _ := fuzzybool.New(.25) // использовании заведомо допустимых значений, но при
	c, _ := fuzzybool.New(.75) // использовании переменных проверка необходима.
	d := c.Copy()
	if err := d.Set(1); err != nil {
		fmt.Println(err)
	}
	process(a, b, c, d)
	s := []*fuzzybool.FuzzyBool{a, b, c, d}
	fmt.Println(s)
}
func process(a, b, c, d *fuzzybool.FuzzyBool) {
	fmt.Println("Original:", a, b, c, d)
	fmt.Println("Not: ", a.Not(), b.Not(), c.Not(), d.Not())
	fmt.Println("Not Not: ", a.Not().Not(), b.Not().Not(), c.Not().Not(),	d.Not().Not())
	fmt.Print("0.And(.25) ˧ ", a.And(b), "• .25.And(.75) ˧ ", b.And(c),	"• .75.And(1) ˧ ", c.And(d), " • .25.And(.75,1) ˧ ", b.And(c, d), "\n")
	fmt.Print("0.Or(.25) ˧ ", a.Or(b), "• .25.Or(.75) ˧ ", b.Or(c),	"• .75.Or(1) ˧ ", c.Or(d), " • .25.Or(.75,1) ˧ ", b.Or(c, d), "\n")
	fmt.Println("a < c, a == c, a > c:", a.Less(c), a.Equal(c), c.Less(a))
	fmt.Println("Bool: ", a.Bool(), b.Bool(), c.Bool(), d.Bool())
	fmt.Println("Float: ", a.Float(), b.Float(), c.Float(), d.Float())
}
________________________
Original: 0% 25% 75% 100%
Not:
100% 75% 25% 0%
Not Not: 0% 25% 75% 100%
0.And(.25) ˧ 0% .25.And(.75) ˧ 25% .75.And(1) ˧ 75% 0.And(.25,.75,1) ˧ 0%
0.Or(.25) ˧ 25% .25.Or(.75) ˧ 75% .75.Or(1) ˧ 100% 0.Or(.25,.75,1) ˧ 100%
a < c, a == c, a > c: true false false
Bool:
false false true true
Float:
0 0.25 0.75 1
[0% 25% 75% 100%]
{% endhighlight %}

Разрабатываемый тип называется FuzzyBool. Сначала рассмотрим
определение самого типа, затем перейдем к функции-конструктору
и закончим изучением методов.

{% highlight go %} 
type FuzzyBool struct{ value float32 }
{% endhighlight %}

Тип FuzzyBool основан на структуре, содержащей единственное
поле типа float32. Поле value является неэкспортируемым, поэтому
для создания значений типа FuzzyBool в пакетах, импортирующих
пакет fuzzybool, необходимо использовать функцию-конструктор
(получившую имя New() в соответствии с соглашениями, принятыми
в языке Go). Это означает, что мы можем гарантировать создание
допустимых значений типа FuzzyBool.

Так как тип FuzzyBool основан на структуре, содержащей значение
с уникальным типом внутри структуры, определение типа можно
было бы упростить до type FuzzyBool struct { float32 }. При этом
пришлось бы изменить выражения доступа к значению (их можно
увидеть в реализациях методов, следующих ниже) с fuzzy.value на
fuzzy.float32. Однако предпочтение было отдано именованному по-
лю, потому что такой программный код выглядит более эстетично
и отчасти потому, что это потребует внести намного меньше изме-
нений, если позднее потребуется изменить тип поля (например, на
float64 ).

Поскольку структура содержит единственное значение, возмож-
ны и другие вариации в определении типа. Например, можно бы-
ло бы определить тип как type FuzzyBool float32, основав его не-
посредственно на типе float32. Такой тип тоже с успехом можно
было бы использовать, но для работы с ним потребовалось бы пи-
сать чуть больше программного кода, и его методы получились бы
сложнее, чем в случае подхода на основе структуры, предпринятого
здесь. Однако, если сделать значения типа FuzzyBool неизменяемыми (то есть для изменения значения использовать не метод Set(), а
оператор присваивания), определение нового логического типа непосредственно на основе типа float32 позволило бы существенно
упростить программный код.

{% highlight go %} 
func New(value interface{}) (*FuzzyBool, error) {
	amount, err := float32ForValue(value)
	return &FuzzyBool{amount}, err
}
{% endhighlight %}

Для удобства пользователей типа FuzzyBool инициализировать новые значения этого типа можно не только значениями типа float32, но
и значениями типа float64 (тип вещественных чисел, используемый в
языке Go по умолчанию), int (целочисленный тип по умолчанию) и
bool. Такая гибкость достигается за счет использования собственной
функции float32ForValue(), возвращающей значение типа float32
и nil для указанного значения, или 0.0 и значение типа error , если
функции было передано значение неподдерживаемого типа.

При передаче значения недопустимого типа необходимо немед-
ленно сообщить об ошибке. Но здесь нежелательно генерировать
аварийную ситуацию, которая может вызвать крах приложения.
Поэтому вместе со значением типа *FuzzyBool возвращается также
значение типа error. Если функции New() передается заведомо допустимый литерал значения (как в примере выше), признак ошибки
можно смело игнорировать, но при передаче переменных необходи-
мо обязательно проверять возвращаемое значение типа error.

Функция New() возвращает указатель на значение типа FuzzyBool,
а не само значение, потому что было принято решение сделать значения изменяемыми. Это означает, что методам, изменяющим значение типа FuzzyBool (в данном примере – единственный метод Set()),
приемник должен передаваться по указателю , а не по значению (1) .

Как правило, для неизменяемых типов создаются методы, принимающие приемник по значению, а для изменяемых – по указателю.
(Для изменяемых типов вполне возможно реализовать в одних методах передачу приемника по значению, а в других – по указателю,
но на практике это не всегда удобно.) Кроме того, указатели лучше
подходят для работы с большими составными типами (например, с
двумя и более полями), чтобы их значения можно было передавать
в виде одного простого указателя.


{% highlight go %} 
func float32ForValue(value interface{}) (fuzzy float32, err error) {
	switch value := value.(type) { // затеняющая переменная
		case float32:
			fuzzy = value
		case float64:
			fuzzy = float32(value)
		case int:
			fuzzy = float32(value)
		case bool:
			fuzzy = 0
			if value {
				fuzzy = 1
			}
		default:
			return 0, fmt.Errorf("float32ForValue(): %v is not a " + "number or Boolean", value)
	}
	if fuzzy < 0 {
		fuzzy = 0
	} else if fuzzy > 1 {
		fuzzy = 1
	}
	return fuzzy, nil
}
{% endhighlight %}

Эта неэкспортируемая вспомогательная функция используется
методами New() и Set() для преобразования значения value в зна-
чение типа float32 в диапазоне [0.0, 1.0]. Обработка исходных зна-
чений различных типов легко реализуется с помощью инструкции
switch выбора по типу (§5.2.2.2).

Если функции передается значение недопустимого типа, она воз-
вращает непустое значение типа error. Это позволяет вызывающей
программе проверить возвращаемое значение и предпринять необ-
ходимые действия в случае появления ошибки. Вызывающая про-
грамма может возбудить аварийную ситуацию и вызвать крах при-
ложения с выводом трассировочной информации или как-то иначе
решить проблему. В низкоуровневых функциях, подобных этой,
часто лучше просто возвращать признак ошибки, чтобы сообщить
о проблеме, потому что они не обладают достаточной информаци-
ей о логике работы приложения и о том, как следует обрабатывать
ошибку, тогда как вызывающая программа находится в лучшем по-
ложении и знает, какие действия следует предпринять.

Передача значения недопустимого типа определенно является
программной ошибкой, и потому имеет смысл возвращать непустое
значение типа error, но для значений допустимых типов выбран
более либеральный подход – значения вне допустимого диапазона
просто преобразуются в ближайшее допустимое значение.

{% highlight go %} 
func (fuzzy *FuzzyBool) String() string {
	return fmt.Sprintf("%.0f%%", 100*fuzzy.value)
}
{% endhighlight %}

Этот метод реализует интерфейс fmt.Stringer . Это означает, что
значения типа FuzzyBool будут выводиться, как указано здесь, и мо-
гут передаваться везде, где ожидается значение, реализующее интер-
фейс fmt.Stringer.

Значения типа FuzzyBool будут выводиться в виде целого числа
процентов. (Напомню, что спецификатор формата "%.0f" обеспечи-
вает вывод вещественных чисел без десятичной точки и без дробной
части, а спецификатор "%%" – вывод одного символа «%». О форма-
тировании строк подробно рассказывается в §3.5.)

{% highlight go %}
func (fuzzy *FuzzyBool) Set(value interface{}) (err error) {
	fuzzy.value, err = float32ForValue(value)
	return err
}
{% endhighlight %}

Этот метод обеспечивает изменяемость значений типа FuzzyBool.
Он очень похож на функцию New(), только здесь не создается ново-
го значения, а выполняются операции с существующим значением
*FuzzyBool. Если полученное значение value является недопусти-
мым, вызывающей программе возвращается непустое значение типа
error и предполагается, что она проверит его.

{% highlight go %}
func (fuzzy *FuzzyBool) Copy() *FuzzyBool {
	return &FuzzyBool{fuzzy.value}
}
{% endhighlight %}

Для типов, значения которых передаются по указателю, часто
бывает удобно реализовать метод Copy(). Данный метод просто соз-
дает новое значение типа FuzzyBool, копию приемника и возвращает
указатель на него. Здесь нет необходимости проверять допустимость
исходного значения, так как приемник всегда будет иметь допусти-
мое значение. При этом, разумеется, предполагается, что при созда-
нии оригинального значения вызовом функции New() и его после-
дующих изменениях с помощью метода Set() было получено пустое
значение типа error.

{% highlight go %}
func (fuzzy *FuzzyBool) Not() *FuzzyBool {
	return &FuzzyBool{1 - fuzzy.value}
}
{% endhighlight %}

Это первый метод, реализующий логическую операцию, и, подоб-
но другим методам логических операторов, он принимает приемник
типа *FuzzyBool.

Реализовать этот метод можно было бы тремя способами. Пер-
вый: изменить значение приемника и ничего не возвращать. Второй:
изменить значение приемника и вернуть его – этот подход исполь-
зуется многими методами типов big.Int и big.Rat в стандартной
библиотеке. Такой прием позволяет составлять цепочки из операций
(например, b.Not().Not()). Он также дает возможность экономить
память (благодаря повторному использованию существующих зна-
чений), но он может превратиться в источник ошибок, если забыть,
что метод возвращает то же значение, относительно которого он вы-
зывался, и что это значение изменяется. Третий способ – тот, что
реализован здесь: оставить исходное значение нетронутым и вернуть
новое значение типа FuzzyBool с результатом логической операции.
Этот способ прост, понятен и поддерживает возможность составле-
ния цепочек из операций, хотя и ценой создания дополнительных
значений. Этот последний способ выбран для всех методов типа
FuzzyBool, реализующих логические операции.

Логика работы операции НЕ (NOT) проста, она возвращает 1.0
для исходного значения 0.0, 0.0 – для исходного значения 1.0, 0.75 –
для исходного значения 0.25, 0.25 – для исходного значения 0.75,
0.5 – для исходного значения 0.5 и т. д.

{% highlight go %}
func (fuzzy *FuzzyBool) And(first *FuzzyBool, rest ...*FuzzyBool) *FuzzyBool {
	minimum := fuzzy.value
	rest = append(rest, first)
	for _, other := range rest {
		if minimum > other.value {
			minimum = other.value
		}
	}
	return &FuzzyBool{minimum}
}
{% endhighlight %}

Операция И (AND) возвращает минимальное из указанных
значений. Сигнатура метода гарантирует, что его можно будет вы-
звать как минимум с одним значением (first) типа *FuzzyBool,
при этом ему можно передать нуль или более дополнительных
значений (rest). Метод просто добавляет значение first в конец
(возможно, пустого) среза rest и затем выполняет итерации по
срезу в поисках минимального значения, меньше значения при-
емника. Подобно методу Not() он возвращает новое значение типа
*FuzzyBool, оставляя нетронутым значение, относительно которого
он вызывался.

Операция ИЛИ (OR) возвращает максимальное из указанных
значений. Метод Or() здесь не показан, потому что структурно он
идентичен методу And(). Единственное отличие состоит в том, что
в методе Or() вместо переменной minimum используется переменная
maximum и сравнение выполняется с помощью оператора < вместо
оператора >.

{% highlight go %}
func (fuzzy *FuzzyBool) Less(other *FuzzyBool) bool {
	return fuzzy.value < other.value
}
func (fuzzy *FuzzyBool) Equal(other *FuzzyBool) bool {
	return fuzzy.value == other.value
}
{% endhighlight %}

Эти два метода позволяют сравнивать значения типа FuzzyBool в
терминах вещественных чисел типа float32. Оба метода возвращают
результат типа bool.

{% highlight go %}
func (fuzzy *FuzzyBool) Bool() bool {
	return fuzzy.value >= .5
}
func (fuzzy *FuzzyBool) Float() float64 {
	return float64(fuzzy.value)
}
{% endhighlight %}

Функцию-конструктор fuzzybool.New() можно рассматривать как
функцию преобразования типа, поскольку она может принимать зна-
чения типов float32, float64, int и bool, и возвращает значение типа
*FuzzyBool. Два метода выше выполняют обратные преобразования.
Тип FuzzyBool представляет собой законченный логический тип
данных для применения в системах нечеткой логики, который мож-
но использовать подобно любым другим пользовательским типам.

То есть значения типа *FuzzyBool можно сохранять в срезах, в виде
ключей и значений в отображениях. Разумеется, при использовании
значений *FuzzyBool в качестве ключей отображений существует
возможность сохранить несколько ключей с одинаковыми факти-
ческими значениями, потому что каждое из них будет иметь уни-
кальный адрес в памяти. Одно из решений этой проблемы состоит в
том, чтобы использовать фактические значения (как показано в при-
мере fuzzy_value, который можно найти в загружаемых примерах
к книге). Как вариант можно было бы использовать собственный
тип коллекций, хранящих указатели, но выполняющих сравнение
по фактическим значениям: подобную возможность предоставляет
пользовательский тип omap.Map, если передать ему соответствующую
функцию сравнения (§6.5.3).

Помимо типа FuzzyBool, представленного в этом подразделе, в
загружаемых примерах к книге можно также найти три альтер-
нативные реализации: они не показаны и не обсуждаются в книге.
Первые две альтернативы находятся в файлах fuzzy_value/fuzzy-
bool/fuzzybool.go и fuzzy_mutable/fuzzybool/fuzzybool.go – они об-
ладают точно такой же функциональностью, что и версия, описан-
ная в этом подразделе (находится в файле fuzzy/fuzzybool/fuzzy-
bool.go). Версия fuzzy_value оперирует значениями типа FuzzyBool
вместо *FuzzyBool, а версия fuzzy_mutable основана не на структуре,
а непосредственно на типе float32. Реализация примера fuzzy_mu-
table получилась немного длиннее и сложнее, чем версия на основе
структуры, представленная здесь. Третья версия обладает меньшими
функциональными возможностями, потому что она реализует неиз-
меняемый тип FuzzyBool. Она также основана непосредственно на
типе float32 и находится в файле fuzzy_immutable/fuzzybool/fuzzy-
bool.go. Это самая простая из трех реализаций.

## 6.5.2. Пример: фигуры – семейство пользовательских типов

Когда имеется множество взаимосвязанных сущностей, таких как
геометрические фигуры, к которым можно было бы применить не-
которые общие операции (например, нарисовать фигуру), для их ре-
ализации можно использовать два основных подхода. Первый, более
привычный для программистов на C++, Java и Python, состоит в ис-
пользовании иерархии типов, или, если говорить в терминах языка
Go, встроенных интерфейсов. Однако часто удобнее создать мно-
жество независимых интерфейсов, которые затем можно свободно
компоновать. В этом подразделе будут показаны оба подхода, пер-
вый – в файле shaper1/shapes/shapes.go и второй – в файле shaper2/
shapes/shapes.go. (Обратите внимание, что когда речь будет идти
о типах, функциях и методах, одинаковых для обеих реализаций,
каковыми являются большинство из них, упоминаться будет просто
пакет shapes. Естественно, когда необходимо будет подчеркнуть раз-
личия, будет упоминаться пакет shaper1/
shapes или пакет shaper2/shapes.)

На рис. 6.3 изображено, что можно
получить с помощью пакета shapes, – в
данном случае с помощью пакета был
нарисован белый прямоугольник внутри
круга и несколько многоугольников с 
различным количеством сторон и разных 
цветов.

!["Рис. 6.3. Пример различным количеством сторон и разных использования пакета shaper; файл shapes.png"](/images/ris-6-3.jpg "Рис. 6.3. Пример различным количеством сторон и разных использования пакета shaper; файл shapes.png")

Пакет shapes экспортирует три функции для работы с изображени-
ями и определяет три типа фигур, из которых экспортируются только
два. Пакет shapes1/shapes, иллюстрирующий иерархическое решение,
экспортирует три интерфейса, а пакет shapes2/shapes, иллюстрирую-
щий композиционное решение, экспортирует пять интерфейсов. Для
начала рассмотрим вспомогательные функции, предназначенные для
работы с изображениями, затем перейдем к интерфейсам (они будут
рассматриваться в двух отдельных подразделах) и, наконец, рассмо-
трим программный код для работы с фигурами.

### 6.5.2.1. Вспомогательные функции

Пакет image из стандартной библиотеки экспортирует интерфейс
image.Image . Этот интерфейс определяет три метода: image.Image.
ColorModel(), возвращающий цветовую модель изображения (как
значение типа color.Model), image.Image.Bounds(), возвращающий
прямоугольник, ограничивающий область изображения (как значе-
ние типа image.Rectangle), и image.Image.At(x, y), возвращающий
значение цвета типа color.Color для указанного пикселя. Приме-
чательно, что интерфейс image.Image не определяет метода для из-
менения пикселя, даже при том, что некоторые типы в пакете image
имеют метод Set(x, y int, fill color.Color). Однако в пакете
image/draw имеется интерфейс draw.Image, встраивающий интерфейс
image.Image, который определяет метод Set(). Среди прочих интер-
фейс draw.Image реализуется типами image.Gray и image.RGBA из стан-
дартной библиотеки.

{% highlight go %}
	func FilledImage(width, height int, fill color.Color) draw.Image {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	width = saneLength(width)
	height = saneLength(height)
	img := image.NewRGBA(image.Rect(0, 0, width, height))
	draw.Draw(img, img.Bounds(), &image.Uniform{fill}, image.ZP, draw.Src)
	return img
}
{% endhighlight %}

Это экспортируемая вспомогательная функция, которая создает
изображение указанного размера, равномерно залитое указанным
цветом.

Сначала функция замещает значение nil цвета черным цветом и
подгоняет оба размера под допустимые значения. Затем она создает
значение типа image.RGBA (изображение, цвета в котором определя-
ются в виде значений красной, зеленой и синей составляющих, а
также степени прозрачности) и возвращает его как значение типа
draw.Image, поскольку нам важны функциональные возможности, а
не фактический тип.

Функция draw.Draw() принимает целевое изображение (типа draw.
Image ), прямоугольник области рисования (в данном случае все изо-
бражение), исходное изображение для копирования (в данном случае
изображение с бесконечными размерами, залитое указанным цветом),
координаты прямоугольника для рисования (image.ZP – это нулевая
точка, то есть точка с координатами (0, 0)) и метод рисования. Здесь
выбран метод draw.Src, поэтому функция просто скопирует исходное
изображение в целевое. То есть функция окрасит каждый пиксель
целевого исходного изображения указанным цветом. (В пакете draw
имеется также функция draw.DrawMask() , поддерживающая возмож-
ность применения различных правил слияния пикселей.)

{% highlight go %}
var saneLength, saneRadius, saneSides func(int) int
func init() {
	saneLength = makeBoundedIntFunc(1, 4096)
	saneRadius = makeBoundedIntFunc(1, 1024)
	saneSides = makeBoundedIntFunc(3, 60)
}
{% endhighlight %}

Здесь определяются три неэкспортируемые переменные для хра-
нения ссылок на вспомогательные функции, каждая из которых при-
нимает значение типа int и возвращает значение типа int. Кроме то-
го, для данного пакета реализована функция init() , где переменным
присваиваются ссылки на соответствующие анонимные функции .

{% highlight go %}
func makeBoundedIntFunc(minimum, maximum int) func(int) int {
	return func
	func(x int) int {
		valid := x
		switch {
			case x < minimum:
				valid = minimum
			case x > maximum:
				valid = maximum
		}
		if valid != x {
			log.Printf("%s(): replaced %d with %d\n", caller(1), x, valid)
		}
		return valid
	}
}
{% endhighlight %}

Эта функция возвращает другую функцию, возвращающую ука-
занное значение x, если оно находится между значениями minimum и
maximum (включительно), или ближайшее граничное значение.

Если значение x находится за границами диапазона, функция не
только возвращает допустимое альтернативное значение, но еще и
регистрирует проблему в журнале. Однако в сообщении об обнару-
женной проблеме не должно фигурировать имя функции, созданной
здесь (то есть saneLength(), saneRadius() или saneSides()), потому что
фактически проблема рождается в вызывающих их функциях. По-
этому вместо имени функции, созданной здесь, в журнал выводится
имя вызывающей функции, которое возвращает функция caller().

{% highlight go %}
func caller(steps int) string {
	name := "?"
	if pc, _, _, ok := runtime.Caller(steps + 1); ok {
		name = filepath.Base(runtime.FuncForPC(pc).Name())
	}
	return name
}
{% endhighlight %}

Функция runtime.Caller() возвращает информацию о функции,
которая была вызвана в текущей go-подпрограмме, но еще не вер-
нула управление. Ее аргумент типа int сообщает, на сколько шагов
(то есть функций) назад следует заглянуть. При значении 0 аргумен-
та возвращается информация о текущей функции (то есть о самой
функции shapes.caller()), при значении 1 возвращается информа-
ция о вызвавшей ее функции и т. д. Здесь к значению аргумента
добавляется 1, чтобы сразу начать с вызывающей функции.

Функция runtime.Caller() возвращает четыре значения: про-
граммный счетчик (сохраняется в переменной pc), имя файла и но-
мер строки, где произошел вызов (оба значения игнорируются за
счет присваивания пустым идентификаторам ), и логический флаг
(сохраняется в переменной ok), сообщающий об успешной или не-
удачной попытке извлечения информации.

В случае успеха программный счетчик передается функции
runtime.FuncForPC() , возвращающей значение типа *runtime.Func,
которое затем передается методу runtime.Func.Name() для полу-
чения имени вызывающей функции. Возвращаемое имя имеет
вид пути к файлу, например: /home/mark/goeg/src/shaper1/shapes.
FilledRectangle – для функции, или /home/mark/goeg/src/shaper1/
shapes.*shape•SetFill – для метода. Для небольших проектов путь
к файлу не представляет интереса, поэтому здесь он отбрасывается
с помощью функции filepath.Base() . После этого имя возвращается
вызывающей программе.

Например, если вызвать функцию shapes.FilledImage() и пере-
дать ей значение, выходящее за допустимый диапазон, такое как
5000, проблема будет исправлена в функции saneLength(). Кроме
того, проблема будет зафиксирована в журнале в виде сообщения:
"shapes.FilledRectangle(): replaced 5000 with 4096". Это обуслов-
лено тем, что saneLength() вызовет caller() со значением аргумен-
та 1, к которому функция caller() прибавит 1 и запросит информа-
цию о третьей функции, вверх по стеку: 0 – сама функция caller(),
1 – saneLength() и 2 – FilledImage().

{% highlight go %}
func DrawShapes(img draw.Image, x, y int, shapes ...Shaper) error {
	for _, shape := range shapes {
		if err := shape.Draw(img, x, y); err != nil {
			return err
		}
	}
	return nil
}
{% endhighlight %}

Это еще одна экспортируемая вспомогательная функция, и един-
ственная, реализованная в разных пакетах shapes по-разному. Выше
представлена версия из пакета shapes1/shapes, реализующего иерар-
хический подход. Функция в пакете shapes2/shapes, реализующем
композиционный подход, отличается только сигнатурой, где она при-
нимает значения типа Drawer, то есть реализующие интерфейс Drawer
(имеющие метод Draw()), вместо значений типа Shaper, которые долж-
ны иметь методы Draw(), Fill() и SetFill(). Другими словами, при
композиционном подходе используется более специализированный и
менее требовательный тип аргумента (Drawer), чем при иерархиче-
ском (требующем реализации интерфейса Shaper). Эти интерфейсы
будут рассматриваться в следующих двух подподразделах.

Тело функции и ее поведение в обоих случаях ничем не отлича-
ются. Функция принимает изображение draw.Image, в котором вы-
полняется рисование, позицию (координаты x и y) и нуль или более
значений типа Shaper (или Drawer). Внутри цикла каждой фигуре
предлагается нарисовать себя в изображении, в указанной позиции.
В процессе рисования координаты x и y проверяются в низкоуровне-
вом методе Draw() фигуры, и если они оказываются недопустимыми,
метод возвращает непустой признак ошибки, который немедленно
передается вызывающей программе.

При создании изображения на рис. 6.3 (выше) использовалась
модифицированная версия этой функции, которая рисует каждую
фигуру три раза. Первый раз – в указанных координатах x и y, вто-
рой – со смещением на один пиксель вправо и третий – со сме-
щением на один пиксель вниз. Это было сделано, чтобы увеличить
толщину линий на снимке с экрана.

{% highlight go %}
func SaveImage(img image.Image, filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	switch strings.ToLower(filepath.Ext(filename)) {
		case ".jpg", ".jpeg":
			return jpeg.Encode(file, img, nil)
		case ".png":
			return png.Encode(file, img)
	}
	return fmt.Errorf("shapes.SaveImage(): ‘%s’ has an unrecognized "+"suffix", filename)
}
{% endhighlight %}

Это последняя из экспортируемых вспомогательных функций.
Она получает значение изображения, реализующее интерфейс
image.Image, которым может быть любое значение, реализующее ин-
терфейс draw.Image, так как он встраивает интерфейс image.Image.
Функция пытается сохранить изображение в файл с указанным име-
нем. Если функция os.Create() потерпит неудачу (например, из-за
того, что было указано пустое имя файла, или из-за ошибки ввода/
вывода), или имя файла имеет неподдерживаемое расширение, или
потерпела неудачу попытка кодирования изображения, функция
возвращает непустой признак ошибки.

На момент написания этих строк стандартная библиотека языка
Go поддерживала для чтения и записи два формата файлов с изо-
бражениями: .png (Portable Network Graphics – переносимая сетевая
графика) и .jpg (Joint Photographic Experts Group – объединен-
ная экспертная группа по фотографии). Пакеты поддержки допол-
нительных форматов изображений доступны на сайте godashboard.
appspot.com/project. Функция jpeg.Encode() имеет дополнительный
аргумент, который можно использовать для тонкой настройки па-
раметров сохранения изображения – здесь в этом аргументе пере-
дается nil, что соответствует настройкам по умолчанию.

Эти функции кодирования могут возбуждать аварийную ситуа-
цию, например если вместо значения типа image.Image передать nil.
Поэтому, чтобы защитить программу от ошибок, можно было бы
предусмотреть отложенный вызов функции, вызывающей функцию
recover() , либо в этой функции, либо в одной из вызывающих функ-
ций (§5.5.1). Здесь было решено не добавлять такую защиту, потому
что контрольные тесты (здесь не показаны) производят достаточное
количество вызовов функции, и можно с уверенностью сказать, что
ошибка проявится при первом же тестировании и вызовет аварий-
ное завершение программы. Поэтому ее практически невозможно
будет пропустить.

Благодаря поддержке интерфейса draw.Image можно определять
значения изображений, позволяющие изменять цвет отдельных
пикселей. С помощью функции DrawShapes() можно рисовать фигу-
ры (значения, реализующие интерфейс Shaper или Drawer) в таких
изображениях. А вызовом функции SaveImage() можно сохранять
изображения на диске. Помимо этих вспомогательных функций,
нам необходимо определить интерфейсы (такие как Shaper, Drawer
и др.), а также конкретные типы с их методами реализации ин-
терфейсов.

### 6.5.2.2. Иерархия встроенных интерфейсов

Программисты с опытом обычного объектно-ориентированного
программирования на основе наследования наверняка предпочтут
использовать встроенные интерфейсы для создания их иерархии.
Рекомендуемый же способ основан на композиционной модели, ко-
торая будет рассматриваться в следующем подподразделе, а здесь
мы познакомимся с иерархической моделью, реализованной в па-
кете shapes1/shapes.

{% highlight go %}
type Shaper interface {
	Fill() color.Color
	SetFill(fill color.Color)
	Draw(img draw.Image, x, y int) error
}
type CircularShaper interface {
	Shaper // Fill(); SetFill(); Draw()
	Radius() int
	SetRadius(radius int)
}
type RegularPolygonalShaper interface {
	CircularShaper // Fill(); SetFill(); Draw(); Radius(); SetRadius()
	Sides() int
	SetSides(sides int)
}
{% endhighlight %}

Здесь путем встраивания, не наследования, создается иерархия из
трех интерфейсов , определяющих методы для фигур.

Интерфейс Shaper определяет методы для получения и изменения цвета заливки – значений типа color.Color, а также метод
рисования фигуры в заданной позиции в изображении draw.Image.
Интерфейс CircularShaper встраивает интерфейс Shaper, а также
добавляет методы получения и изменения значения радиуса типа
int. Аналогично интерфейс RegularPolygonalShaper встраивает интерфейс CircularShaper (и через него интерфейс Shaper) и добавляет
методы получения и изменения числа сторон типа int.

Несмотря на то что подход на основе создания иерархий, подобных этой, может быть многим знаком и дает положительные результаты, тем не менее это не самый лучший способ решения задач на
языке Go. Причина в том, что такой подход запирает программиста
в рамках иерархии, даже когда в иерархии нет никакой необходимости: в действительности здесь необходимо лишь обеспечить реализацию подходящих интерфейсов в фигурах. Это даст больше гибкости,
как будет показано в следующем подподразделе.

### 6.5.2.3. Свободно компонуемые независимые интерфейсы

В фигурах основной интерес представляют операции, которые можно выполнять над ними (рисование, получение/изменение цвета заливки, получение/изменение величины радиуса и т. д.), обладающие
некоторой долей универсальности. Ниже представлены интерфейсы,
объявленные в пакете shapes2/shapes, реализующем композиционный подход.

{% highlight go %}
type Shaper interface {
	Drawer // Draw()
	Filler // Fill(); SetFill()
}
type Drawer interface {
	Draw(img draw.Image, x, y int) error
}
type Filler interface {
	Fill() color.Color
	SetFill(fill color.Color)
}
type Radiuser interface {
	Radius() int
	SetRadius(radius int)
}
type Sideser interface {
	Sides() int
	SetSides(sides int)
}
{% endhighlight %}

Интерфейс Shaper в этом пакете демонстрирует простой способ
определения обобщенной фигуры, то есть фигуры, которую можно нарисовать и которая позволяет получить/изменить цвет заливки. Все
остальные интерфейсы определяют более специализированные особенности (получение и изменение дополнительных параметров фигур).

Множество независимых интерфейсов обеспечивают большую
гибкость, чем их иерархия. Например, при использовании функции DrawShapes() можно более точно определять передаваемые ей
фигуры, чем это было возможно в иерархической модели. Кроме
того, в отсутствие иерархии можно более свободно добавлять другие
интерфейсы и, конечно же, при наличии множества узкоспециализированных интерфейсов их проще компоновать для достижения
требуемого результата, как это видно на примере интерфейса Shaper.

Две разные версии пакета shapes имеют совершенно отличные интерфейсы (даже при том, что в обоих имеется интерфейс Shaper, их
тела совершенно отличаются). Тем не менее, поскольку интерфейсы
и конкретные типы полностью независимы друг от друга, эти различия практически не оказывают влияния на конкретную реализацию
интерфейсов.

### 6.5.2.4. Конкретные типы и методы

Это последний подподраздел с описанием пакета shapes – здесь будут представлены конкретные реализации интерфейсов, описанных
в двух предыдущих подподразделах.

{% highlight go %}
type shape struct{ fill color.Color }
func newShape(fill color.Color) shape {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	return shape{fill}
}
func (shape shape) Fill() color.Color { 
	return shape.fill 
}
func (shape *shape) SetFill(fill color.Color) {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	shape.fill = fill
}
{% endhighlight %}

Этот простой тип является неэкспортируемым, поэтому он доступен только внутри пакета shapes. То есть значение типа shape не
может быть создано за пределами пакета.

В иерархическом пакете shaper1/shapes этот тип не реализует ни
один из интерфейсов из-за отсутствия метода Draw(). Но в композиционном пакете shaper2/shapes он реализует интерфейс Filler.

В программном коде только тип Circle (который рассматривается
чуть ниже) встраивает интерфейс shape непосредственно. Поэтому
теоретически в тип Circle можно было бы добавить поле типа color.
Color, реализовать методы получения и изменения цвета, принимающие приемник типа *Circle вместо типа *shape и полностью избавиться от типа shape. Однако для большей гибкости лучше оставить
тип shape, потому что это упрощает добавление дополнительных интерфейсов и типов фигур, которые могут основываться непосредственно на типе shape (то есть иметь цвет), а не на типе Circle (например, из-за неприменимости к ним понятия радиус). Эта гибкость еще пригодится при выполнении одного из упражнений.


{% highlight go %}
type Circle struct {
	shape
	radius int
}
func NewCircle(fill color.Color, radius int) *Circle {
	return &Circle{newShape(fill), saneRadius(radius)}
}
func (circle *Circle) Radius() int {
	return circle.radius
}
func (circle *Circle) SetRadius(radius int) {
	circle.radius = saneRadius(radius)
}
func (circle *Circle) Draw(img draw.Image, x, y int) error {
// ... около 30 строк ...
}
func (circle *Circle) String() string {
	return fmt.Sprintf("circle(fill=%v, radius=%d)", circle.fill, circle.radius)
}
{% endhighlight %}

Это полная реализация типа Circle. Несмотря на возможность
создавать значения конкретного типа *Circle, их можно передавать как интерфейсы, что обеспечивает значительную гибкость.
Например, функция DrawShapes() принимает значения, реализующие интерфейс Shaper (или Drawer), независимо от их конкретного типа.

В иерархическом пакете shaper1/shapes этот тип реализует интерфейсы CircularShaper и Shaper. В композиционном пакете shaper2/
shapes он реализует интерфейсы Filler, Radiuser, Drawer и Shaper. И
в обоих пакетах этот тип также реализует интерфейс fmt.Stringer.

Поскольку в языке Go отсутствуют конструкторы типов и в определении типа имеются неэкспортируемые поля, необходимо реализовать функцию-конструктор, которая должна вызываться явно.
Функция-конструктор для типа Circle называется NewCircle() –
далее можно будет увидеть, что в пакете имеется также функция
New(), способная создавать значения любых типов фигур из пакета
shapes. Вспомогательная функция saneRadius(), созданная выше,
возвращает переданное ей целое число, если оно попадает в заданный диапазон, в противном случае – ближайшее граничное значение
диапазона.

Реализация метода Draw() была опущена (ее можно найти в загружаемых примерах к книге), так как основной интерес в этой главе
представляют интерфейсы и типы, а не приемы работы с графикой.


{% highlight go %}
type RegularPolygon struct {
	*Circle
	sides int
}
func NewRegularPolygon(fill color.Color, radius, sides int) *RegularPolygon {
	return &RegularPolygon{NewCircle(fill, radius), saneSides(sides)}
}
func (polygon *RegularPolygon) Sides() int {
	return polygon.sides
}
func (polygon *RegularPolygon) SetSides(sides int) {
	polygon.sides = saneSides(sides)
}
func (polygon *RegularPolygon) Draw(img draw.Image, x, y int) error {
// ... примерно 55 строк, включая две вспомогательные функции ...
}
func (polygon *RegularPolygon) String() string {
	return fmt.Sprintf("polygon(fill=%v, radius=%d, sides=%d)",	polygon.Fill(), polygon.Radius(), polygon.sides)
}
{% endhighlight %}





---------------------------
1) В действительности можно было бы возвращать значение типа FuzzyBool
и обеспечить его изменяемость, как показано в примере fuzzy_value , который можно найти в загружаемых примерах к книге.