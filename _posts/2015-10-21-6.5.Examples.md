---
layout: post
title:  "6.5. Примеры"
date:   2015-10-21 13:33:00
categories: go
---

* [6.5.1. Пример: FuzzyBool – пользовательский тип с единственным значением](#fuzzybool------) 
* [6.5.2. Пример: фигуры – семейство пользовательских типов](#section)
* [6.5.2.1. Вспомогательные функции](#section-1)
* [6.5.2.2. Иерархия встроенных интерфейсов](#section-2)
* [6.5.2.3. Свободно компонуемые независимые интерфейсы](#section-3)
* [6.5.2.4. Конкретные типы и методы](#section-4)
* [ 6.5.3. Пример: упорядоченное отображение – обобщенный тип коллекций](#section-5)
* [6.6. Упражнения](#section-6)

Теперь, когда стало понятно, как создавать собственные типы, можно перейти к знакомству с более практичными примерами. Первый
пример демонстрирует, как создать простой тип значения. Второй
пример демонстрирует, как создать множество взаимосвязанных интерфейсов и структур с применением приема встраивания и как реализовать не только функции-конструкторы, но и фабричные функции , чтобы обеспечить возможность создания значений всех типов,
экспортируемых пакетом. Третий пример демонстрирует порядок
реализации законченного универсального типа коллекций.


## 6.5.1. Пример: FuzzyBool – пользовательский тип с единственным значением

В этом разделе будет показано, как создать пользовательский тип
с единственным значением и его методы. Этот пример находится в
файле fuzzy/fuzzybool/fuzzybool.go и основан на структуре.

Встроенный тип bool имеет два возможных значения (true и
false), но в некоторых системах искусственного интеллекта используется нечеткая логика. Логические величины в таких системах
могут иметь не только значения «истина» или «ложь», но также значения, занимающие промежуточные положения. В данной реализации для представления логических значений будут использоваться
вещественные числа: 0.0 – для значения false и 1.0 – для значения
true. В данной реализации значение 0.5 означает 50% истины (50%
лжи), значение 0.25 означает 25% истины (75% лжи) и т. д. Ниже
приводятся несколько примеров использования такого типа.


{% highlight go %}  
func main() {
	a, _ := fuzzybool.New(0)   // Значение ошибки можно смело игнорировать при
	b, _ := fuzzybool.New(.25) // использовании заведомо допустимых значений, но при
	c, _ := fuzzybool.New(.75) // использовании переменных проверка необходима.
	d := c.Copy()
	if err := d.Set(1); err != nil {
		fmt.Println(err)
	}
	process(a, b, c, d)
	s := []*fuzzybool.FuzzyBool{a, b, c, d}
	fmt.Println(s)
}
func process(a, b, c, d *fuzzybool.FuzzyBool) {
	fmt.Println("Original:", a, b, c, d)
	fmt.Println("Not: ", a.Not(), b.Not(), c.Not(), d.Not())
	fmt.Println("Not Not: ", a.Not().Not(), b.Not().Not(), c.Not().Not(),	d.Not().Not())
	fmt.Print("0.And(.25) -> ", a.And(b), "• .25.And(.75) -> ", b.And(c),	"• .75.And(1) -> ", c.And(d), " • .25.And(.75,1) -> ", b.And(c, d), "\n")
	fmt.Print("0.Or(.25) -> ", a.Or(b), "• .25.Or(.75) -> ", b.Or(c),	"• .75.Or(1) -> ", c.Or(d), " • .25.Or(.75,1) -> ", b.Or(c, d), "\n")
	fmt.Println("a < c, a == c, a > c:", a.Less(c), a.Equal(c), c.Less(a))
	fmt.Println("Bool: ", a.Bool(), b.Bool(), c.Bool(), d.Bool())
	fmt.Println("Float: ", a.Float(), b.Float(), c.Float(), d.Float())
}
________________________
Original: 0% 25% 75% 100%
Not:
100% 75% 25% 0%
Not Not: 0% 25% 75% 100%
0.And(.25) -> 0% .25.And(.75) -> 25% .75.And(1) -> 75% 0.And(.25,.75,1) -> 0%
0.Or(.25) -> 25% .25.Or(.75) -> 75% .75.Or(1) -> 100% 0.Or(.25,.75,1) -> 100%
a < c, a == c, a > c: true false false
Bool:
false false true true
Float:
0 0.25 0.75 1
[0% 25% 75% 100%]
{% endhighlight %}

Разрабатываемый тип называется FuzzyBool. Сначала рассмотрим
определение самого типа, затем перейдем к функции-конструктору
и закончим изучением методов.

{% highlight go %} 
type FuzzyBool struct{ value float32 }
{% endhighlight %}

Тип FuzzyBool основан на структуре, содержащей единственное
поле типа float32. Поле value является неэкспортируемым, поэтому
для создания значений типа FuzzyBool в пакетах, импортирующих
пакет fuzzybool, необходимо использовать функцию-конструктор
(получившую имя New() в соответствии с соглашениями, принятыми
в языке Go). Это означает, что мы можем гарантировать создание
допустимых значений типа FuzzyBool.

Так как тип FuzzyBool основан на структуре, содержащей значение
с уникальным типом внутри структуры, определение типа можно
было бы упростить до type FuzzyBool struct { float32 }. При этом
пришлось бы изменить выражения доступа к значению (их можно
увидеть в реализациях методов, следующих ниже) с fuzzy.value на
fuzzy.float32. Однако предпочтение было отдано именованному полю, потому что такой программный код выглядит более эстетично
и отчасти потому, что это потребует внести намного меньше изменений, если позднее потребуется изменить тип поля (например, на
float64 ).

Поскольку структура содержит единственное значение, возможны и другие вариации в определении типа. Например, можно было бы определить тип как type FuzzyBool float32, основав его непосредственно на типе float32. Такой тип тоже с успехом можно
было бы использовать, но для работы с ним потребовалось бы писать чуть больше программного кода, и его методы получились бы
сложнее, чем в случае подхода на основе структуры, предпринятого
здесь. Однако, если сделать значения типа FuzzyBool неизменяемыми (то есть для изменения значения использовать не метод Set(), а
оператор присваивания), определение нового логического типа непосредственно на основе типа float32 позволило бы существенно
упростить программный код.

{% highlight go %} 
func New(value interface{}) (*FuzzyBool, error) {
	amount, err := float32ForValue(value)
	return &FuzzyBool{amount}, err
}
{% endhighlight %}

Для удобства пользователей типа FuzzyBool инициализировать новые значения этого типа можно не только значениями типа float32, но
и значениями типа float64 (тип вещественных чисел, используемый в
языке Go по умолчанию), int (целочисленный тип по умолчанию) и
bool. Такая гибкость достигается за счет использования собственной
функции float32ForValue(), возвращающей значение типа float32
и nil для указанного значения, или 0.0 и значение типа error , если
функции было передано значение неподдерживаемого типа.

При передаче значения недопустимого типа необходимо немедленно сообщить об ошибке. Но здесь нежелательно генерировать
аварийную ситуацию, которая может вызвать крах приложения.
Поэтому вместе со значением типа *FuzzyBool возвращается также
значение типа error. Если функции New() передается заведомо допустимый литерал значения (как в примере выше), признак ошибки
можно смело игнорировать, но при передаче переменных необходимо обязательно проверять возвращаемое значение типа error.

Функция New() возвращает указатель на значение типа FuzzyBool,
а не само значение, потому что было принято решение сделать значения изменяемыми. Это означает, что методам, изменяющим значение типа FuzzyBool (в данном примере – единственный метод Set()),
приемник должен передаваться по указателю , а не по значению (1) .

Как правило, для неизменяемых типов создаются методы, принимающие приемник по значению, а для изменяемых – по указателю.
(Для изменяемых типов вполне возможно реализовать в одних методах передачу приемника по значению, а в других – по указателю,
но на практике это не всегда удобно.) Кроме того, указатели лучше
подходят для работы с большими составными типами (например, с
двумя и более полями), чтобы их значения можно было передавать
в виде одного простого указателя.


{% highlight go %} 
func float32ForValue(value interface{}) (fuzzy float32, err error) {
	switch value := value.(type) { // затеняющая переменная
		case float32:
			fuzzy = value
		case float64:
			fuzzy = float32(value)
		case int:
			fuzzy = float32(value)
		case bool:
			fuzzy = 0
			if value {
				fuzzy = 1
			}
		default:
			return 0, fmt.Errorf("float32ForValue(): %v is not a " + "number or Boolean", value)
	}
	if fuzzy < 0 {
		fuzzy = 0
	} else if fuzzy > 1 {
		fuzzy = 1
	}
	return fuzzy, nil
}
{% endhighlight %}

Эта неэкспортируемая вспомогательная функция используется
методами New() и Set() для преобразования значения value в значение типа float32 в диапазоне [0.0, 1.0]. Обработка исходных значений различных типов легко реализуется с помощью инструкции
switch выбора по типу (§5.2.2.2).

Если функции передается значение недопустимого типа, она возвращает непустое значение типа error. Это позволяет вызывающей
программе проверить возвращаемое значение и предпринять необходимые действия в случае появления ошибки. Вызывающая программа может возбудить аварийную ситуацию и вызвать крах приложения с выводом трассировочной информации или как-то иначе
решить проблему. В низкоуровневых функциях, подобных этой,
часто лучше просто возвращать признак ошибки, чтобы сообщить
о проблеме, потому что они не обладают достаточной информацией о логике работы приложения и о том, как следует обрабатывать
ошибку, тогда как вызывающая программа находится в лучшем положении и знает, какие действия следует предпринять.

Передача значения недопустимого типа определенно является
программной ошибкой, и потому имеет смысл возвращать непустое
значение типа error, но для значений допустимых типов выбран
более либеральный подход – значения вне допустимого диапазона
просто преобразуются в ближайшее допустимое значение.

{% highlight go %} 
func (fuzzy *FuzzyBool) String() string {
	return fmt.Sprintf("%.0f%%", 100*fuzzy.value)
}
{% endhighlight %}

Этот метод реализует интерфейс fmt.Stringer . Это означает, что
значения типа FuzzyBool будут выводиться, как указано здесь, и могут передаваться везде, где ожидается значение, реализующее интерфейс fmt.Stringer.

Значения типа FuzzyBool будут выводиться в виде целого числа
процентов. (Напомню, что спецификатор формата "%.0f" обеспечивает вывод вещественных чисел без десятичной точки и без дробной
части, а спецификатор "%%" – вывод одного символа «%». О форматировании строк подробно рассказывается в §3.5.)

{% highlight go %}
func (fuzzy *FuzzyBool) Set(value interface{}) (err error) {
	fuzzy.value, err = float32ForValue(value)
	return err
}
{% endhighlight %}

Этот метод обеспечивает изменяемость значений типа FuzzyBool.
Он очень похож на функцию New(), только здесь не создается нового значения, а выполняются операции с существующим значением
*FuzzyBool. Если полученное значение value является недопустимым, вызывающей программе возвращается непустое значение типа
error и предполагается, что она проверит его.

{% highlight go %}
func (fuzzy *FuzzyBool) Copy() *FuzzyBool {
	return &FuzzyBool{fuzzy.value}
}
{% endhighlight %}

Для типов, значения которых передаются по указателю, часто
бывает удобно реализовать метод Copy(). Данный метод просто создает новое значение типа FuzzyBool, копию приемника и возвращает
указатель на него. Здесь нет необходимости проверять допустимость
исходного значения, так как приемник всегда будет иметь допустимое значение. При этом, разумеется, предполагается, что при создании оригинального значения вызовом функции New() и его последующих изменениях с помощью метода Set() было получено пустое
значение типа error.

{% highlight go %}
func (fuzzy *FuzzyBool) Not() *FuzzyBool {
	return &FuzzyBool{1 - fuzzy.value}
}
{% endhighlight %}

Это первый метод, реализующий логическую операцию, и, подобно другим методам логических операторов, он принимает приемник
типа *FuzzyBool.

Реализовать этот метод можно было бы тремя способами. Первый: изменить значение приемника и ничего не возвращать. Второй:
изменить значение приемника и вернуть его – этот подход используется многими методами типов big.Int и big.Rat в стандартной
библиотеке. Такой прием позволяет составлять цепочки из операций
(например, b.Not().Not()). Он также дает возможность экономить
память (благодаря повторному использованию существующих значений), но он может превратиться в источник ошибок, если забыть,
что метод возвращает то же значение, относительно которого он вызывался, и что это значение изменяется. Третий способ – тот, что
реализован здесь: оставить исходное значение нетронутым и вернуть
новое значение типа FuzzyBool с результатом логической операции.
Этот способ прост, понятен и поддерживает возможность составления цепочек из операций, хотя и ценой создания дополнительных
значений. Этот последний способ выбран для всех методов типа
FuzzyBool, реализующих логические операции.

Логика работы операции НЕ (NOT) проста, она возвращает 1.0
для исходного значения 0.0, 0.0 – для исходного значения 1.0, 0.75 –
для исходного значения 0.25, 0.25 – для исходного значения 0.75,
0.5 – для исходного значения 0.5 и т. д.

{% highlight go %}
func (fuzzy *FuzzyBool) And(first *FuzzyBool, rest ...*FuzzyBool) *FuzzyBool {
	minimum := fuzzy.value
	rest = append(rest, first)
	for _, other := range rest {
		if minimum > other.value {
			minimum = other.value
		}
	}
	return &FuzzyBool{minimum}
}
{% endhighlight %}

Операция И (AND) возвращает минимальное из указанных
значений. Сигнатура метода гарантирует, что его можно будет вызвать как минимум с одним значением (first) типа *FuzzyBool,
при этом ему можно передать нуль или более дополнительных
значений (rest). Метод просто добавляет значение first в конец
(возможно, пустого) среза rest и затем выполняет итерации по
срезу в поисках минимального значения, меньше значения приемника. Подобно методу Not() он возвращает новое значение типа
*FuzzyBool, оставляя нетронутым значение, относительно которого
он вызывался.

Операция ИЛИ (OR) возвращает максимальное из указанных
значений. Метод Or() здесь не показан, потому что структурно он
идентичен методу And(). Единственное отличие состоит в том, что
в методе Or() вместо переменной minimum используется переменная
maximum и сравнение выполняется с помощью оператора < вместо
оператора >.

{% highlight go %}
func (fuzzy *FuzzyBool) Less(other *FuzzyBool) bool {
	return fuzzy.value < other.value
}
func (fuzzy *FuzzyBool) Equal(other *FuzzyBool) bool {
	return fuzzy.value == other.value
}
{% endhighlight %}

Эти два метода позволяют сравнивать значения типа FuzzyBool в
терминах вещественных чисел типа float32. Оба метода возвращают
результат типа bool.

{% highlight go %}
func (fuzzy *FuzzyBool) Bool() bool {
	return fuzzy.value >= .5
}
func (fuzzy *FuzzyBool) Float() float64 {
	return float64(fuzzy.value)
}
{% endhighlight %}

Функцию-конструктор fuzzybool.New() можно рассматривать как
функцию преобразования типа, поскольку она может принимать значения типов float32, float64, int и bool, и возвращает значение типа
*FuzzyBool. Два метода выше выполняют обратные преобразования.
Тип FuzzyBool представляет собой законченный логический тип
данных для применения в системах нечеткой логики, который можно использовать подобно любым другим пользовательским типам.

То есть значения типа *FuzzyBool можно сохранять в срезах, в виде
ключей и значений в отображениях. Разумеется, при использовании
значений *FuzzyBool в качестве ключей отображений существует
возможность сохранить несколько ключей с одинаковыми фактическими значениями, потому что каждое из них будет иметь уникальный адрес в памяти. Одно из решений этой проблемы состоит в
том, чтобы использовать фактические значения (как показано в примере fuzzy_value, который можно найти в загружаемых примерах
к книге). Как вариант можно было бы использовать собственный
тип коллекций, хранящих указатели, но выполняющих сравнение
по фактическим значениям: подобную возможность предоставляет
пользовательский тип omap.Map, если передать ему соответствующую
функцию сравнения (§6.5.3).

Помимо типа FuzzyBool, представленного в этом подразделе, в
загружаемых примерах к книге можно также найти три альтернативные реализации: они не показаны и не обсуждаются в книге.
Первые две альтернативы находятся в файлах fuzzy_value/fuzzybool/fuzzybool.go и fuzzy_mutable/fuzzybool/fuzzybool.go – они обладают точно такой же функциональностью, что и версия, описанная в этом подразделе (находится в файле fuzzy/fuzzybool/fuzzybool.go). Версия fuzzy_value оперирует значениями типа FuzzyBool
вместо *FuzzyBool, а версия fuzzy_mutable основана не на структуре,
а непосредственно на типе float32. Реализация примера fuzzy_mutable получилась немного длиннее и сложнее, чем версия на основе
структуры, представленная здесь. Третья версия обладает меньшими
функциональными возможностями, потому что она реализует неизменяемый тип FuzzyBool. Она также основана непосредственно на
типе float32 и находится в файле fuzzy_immutable/fuzzybool/fuzzybool.go. Это самая простая из трех реализаций.

## 6.5.2. Пример: фигуры – семейство пользовательских типов

Когда имеется множество взаимосвязанных сущностей, таких как
геометрические фигуры, к которым можно было бы применить некоторые общие операции (например, нарисовать фигуру), для их реализации можно использовать два основных подхода. Первый, более
привычный для программистов на C++, Java и Python, состоит в использовании иерархии типов, или, если говорить в терминах языка
Go, встроенных интерфейсов. Однако часто удобнее создать множество независимых интерфейсов, которые затем можно свободно
компоновать. В этом подразделе будут показаны оба подхода, первый – в файле shaper1/shapes/shapes.go и второй – в файле shaper2/
shapes/shapes.go. (Обратите внимание, что когда речь будет идти
о типах, функциях и методах, одинаковых для обеих реализаций,
каковыми являются большинство из них, упоминаться будет просто
пакет shapes. Естественно, когда необходимо будет подчеркнуть различия, будет упоминаться пакет shaper1/
shapes или пакет shaper2/shapes.)

На рис. 6.3 изображено, что можно
получить с помощью пакета shapes, – в
данном случае с помощью пакета был
нарисован белый прямоугольник внутри
круга и несколько многоугольников с 
различным количеством сторон и разных 
цветов.

!["Рис. 6.3. Пример различным количеством сторон и разных использования пакета shaper; файл shapes.png"](/images/ris-6-3.jpg "Рис. 6.3. Пример различным количеством сторон и разных использования пакета shaper; файл shapes.png")

Пакет shapes экспортирует три функции для работы с изображениями и определяет три типа фигур, из которых экспортируются только
два. Пакет shapes1/shapes, иллюстрирующий иерархическое решение,
экспортирует три интерфейса, а пакет shapes2/shapes, иллюстрирующий композиционное решение, экспортирует пять интерфейсов. Для
начала рассмотрим вспомогательные функции, предназначенные для
работы с изображениями, затем перейдем к интерфейсам (они будут
рассматриваться в двух отдельных подразделах) и, наконец, рассмотрим программный код для работы с фигурами.

### 6.5.2.1. Вспомогательные функции

Пакет image из стандартной библиотеки экспортирует интерфейс
image.Image . Этот интерфейс определяет три метода: image.Image.
ColorModel(), возвращающий цветовую модель изображения (как
значение типа color.Model), image.Image.Bounds(), возвращающий
прямоугольник, ограничивающий область изображения (как значение типа image.Rectangle), и image.Image.At(x, y), возвращающий
значение цвета типа color.Color для указанного пикселя. Примечательно, что интерфейс image.Image не определяет метода для изменения пикселя, даже при том, что некоторые типы в пакете image
имеют метод Set(x, y int, fill color.Color). Однако в пакете
image/draw имеется интерфейс draw.Image, встраивающий интерфейс
image.Image, который определяет метод Set(). Среди прочих интерфейс draw.Image реализуется типами image.Gray и image.RGBA из стандартной библиотеки.

{% highlight go %}
	func FilledImage(width, height int, fill color.Color) draw.Image {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	width = saneLength(width)
	height = saneLength(height)
	img := image.NewRGBA(image.Rect(0, 0, width, height))
	draw.Draw(img, img.Bounds(), &image.Uniform{fill}, image.ZP, draw.Src)
	return img
}
{% endhighlight %}

Это экспортируемая вспомогательная функция, которая создает
изображение указанного размера, равномерно залитое указанным
цветом.

Сначала функция замещает значение nil цвета черным цветом и
подгоняет оба размера под допустимые значения. Затем она создает
значение типа image.RGBA (изображение, цвета в котором определяются в виде значений красной, зеленой и синей составляющих, а
также степени прозрачности) и возвращает его как значение типа
draw.Image, поскольку нам важны функциональные возможности, а
не фактический тип.

Функция draw.Draw() принимает целевое изображение (типа draw.
Image ), прямоугольник области рисования (в данном случае все изображение), исходное изображение для копирования (в данном случае
изображение с бесконечными размерами, залитое указанным цветом),
координаты прямоугольника для рисования (image.ZP – это нулевая
точка, то есть точка с координатами (0, 0)) и метод рисования. Здесь
выбран метод draw.Src, поэтому функция просто скопирует исходное
изображение в целевое. То есть функция окрасит каждый пиксель
целевого исходного изображения указанным цветом. (В пакете draw
имеется также функция draw.DrawMask() , поддерживающая возможность применения различных правил слияния пикселей.)

{% highlight go %}
var saneLength, saneRadius, saneSides func(int) int
func init() {
	saneLength = makeBoundedIntFunc(1, 4096)
	saneRadius = makeBoundedIntFunc(1, 1024)
	saneSides = makeBoundedIntFunc(3, 60)
}
{% endhighlight %}

Здесь определяются три неэкспортируемые переменные для хранения ссылок на вспомогательные функции, каждая из которых принимает значение типа int и возвращает значение типа int. Кроме того, для данного пакета реализована функция init() , где переменным
присваиваются ссылки на соответствующие анонимные функции .

{% highlight go %}
func makeBoundedIntFunc(minimum, maximum int) func(int) int {
	return func
	func(x int) int {
		valid := x
		switch {
			case x < minimum:
				valid = minimum
			case x > maximum:
				valid = maximum
		}
		if valid != x {
			log.Printf("%s(): replaced %d with %d\n", caller(1), x, valid)
		}
		return valid
	}
}
{% endhighlight %}

Эта функция возвращает другую функцию, возвращающую указанное значение x, если оно находится между значениями minimum и
maximum (включительно), или ближайшее граничное значение.

Если значение x находится за границами диапазона, функция не
только возвращает допустимое альтернативное значение, но еще и
регистрирует проблему в журнале. Однако в сообщении об обнаруженной проблеме не должно фигурировать имя функции, созданной
здесь (то есть saneLength(), saneRadius() или saneSides()), потому что
фактически проблема рождается в вызывающих их функциях. Поэтому вместо имени функции, созданной здесь, в журнал выводится
имя вызывающей функции, которое возвращает функция caller().

{% highlight go %}
func caller(steps int) string {
	name := "?"
	if pc, _, _, ok := runtime.Caller(steps + 1); ok {
		name = filepath.Base(runtime.FuncForPC(pc).Name())
	}
	return name
}
{% endhighlight %}

Функция runtime.Caller() возвращает информацию о функции,
которая была вызвана в текущей go-подпрограмме, но еще не вернула управление. Ее аргумент типа int сообщает, на сколько шагов
(то есть функций) назад следует заглянуть. При значении 0 аргумента возвращается информация о текущей функции (то есть о самой
функции shapes.caller()), при значении 1 возвращается информация о вызвавшей ее функции и т. д. Здесь к значению аргумента
добавляется 1, чтобы сразу начать с вызывающей функции.

Функция runtime.Caller() возвращает четыре значения: программный счетчик (сохраняется в переменной pc), имя файла и номер строки, где произошел вызов (оба значения игнорируются за
счет присваивания пустым идентификаторам ), и логический флаг
(сохраняется в переменной ok), сообщающий об успешной или неудачной попытке извлечения информации.

В случае успеха программный счетчик передается функции
runtime.FuncForPC() , возвращающей значение типа *runtime.Func,
которое затем передается методу runtime.Func.Name() для получения имени вызывающей функции. Возвращаемое имя имеет
вид пути к файлу, например: /home/mark/goeg/src/shaper1/shapes.
FilledRectangle – для функции, или /home/mark/goeg/src/shaper1/
shapes.*shape•SetFill – для метода. Для небольших проектов путь
к файлу не представляет интереса, поэтому здесь он отбрасывается
с помощью функции filepath.Base() . После этого имя возвращается
вызывающей программе.

Например, если вызвать функцию shapes.FilledImage() и передать ей значение, выходящее за допустимый диапазон, такое как
5000, проблема будет исправлена в функции saneLength(). Кроме
того, проблема будет зафиксирована в журнале в виде сообщения:
"shapes.FilledRectangle(): replaced 5000 with 4096". Это обусловлено тем, что saneLength() вызовет caller() со значением аргумента 1, к которому функция caller() прибавит 1 и запросит информацию о третьей функции, вверх по стеку: 0 – сама функция caller(),
1 – saneLength() и 2 – FilledImage().

{% highlight go %}
func DrawShapes(img draw.Image, x, y int, shapes ...Shaper) error {
	for _, shape := range shapes {
		if err := shape.Draw(img, x, y); err != nil {
			return err
		}
	}
	return nil
}
{% endhighlight %}

Это еще одна экспортируемая вспомогательная функция, и единственная, реализованная в разных пакетах shapes по-разному. Выше
представлена версия из пакета shapes1/shapes, реализующего иерархический подход. Функция в пакете shapes2/shapes, реализующем
композиционный подход, отличается только сигнатурой, где она принимает значения типа Drawer, то есть реализующие интерфейс Drawer
(имеющие метод Draw()), вместо значений типа Shaper, которые должны иметь методы Draw(), Fill() и SetFill(). Другими словами, при
композиционном подходе используется более специализированный и
менее требовательный тип аргумента (Drawer), чем при иерархическом (требующем реализации интерфейса Shaper). Эти интерфейсы
будут рассматриваться в следующих двух подподразделах.

Тело функции и ее поведение в обоих случаях ничем не отличаются. Функция принимает изображение draw.Image, в котором выполняется рисование, позицию (координаты x и y) и нуль или более
значений типа Shaper (или Drawer). Внутри цикла каждой фигуре
предлагается нарисовать себя в изображении, в указанной позиции.
В процессе рисования координаты x и y проверяются в низкоуровневом методе Draw() фигуры, и если они оказываются недопустимыми,
метод возвращает непустой признак ошибки, который немедленно
передается вызывающей программе.

При создании изображения на рис. 6.3 (выше) использовалась
модифицированная версия этой функции, которая рисует каждую
фигуру три раза. Первый раз – в указанных координатах x и y, второй – со смещением на один пиксель вправо и третий – со смещением на один пиксель вниз. Это было сделано, чтобы увеличить
толщину линий на снимке с экрана.

{% highlight go %}
func SaveImage(img image.Image, filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()
	switch strings.ToLower(filepath.Ext(filename)) {
		case ".jpg", ".jpeg":
			return jpeg.Encode(file, img, nil)
		case ".png":
			return png.Encode(file, img)
	}
	return fmt.Errorf("shapes.SaveImage(): ‘%s’ has an unrecognized "+"suffix", filename)
}
{% endhighlight %}

Это последняя из экспортируемых вспомогательных функций.
Она получает значение изображения, реализующее интерфейс
image.Image, которым может быть любое значение, реализующее интерфейс draw.Image, так как он встраивает интерфейс image.Image.
Функция пытается сохранить изображение в файл с указанным именем. Если функция os.Create() потерпит неудачу (например, из-за
того, что было указано пустое имя файла, или из-за ошибки ввода/
вывода), или имя файла имеет неподдерживаемое расширение, или
потерпела неудачу попытка кодирования изображения, функция
возвращает непустой признак ошибки.

На момент написания этих строк стандартная библиотека языка
Go поддерживала для чтения и записи два формата файлов с изображениями: .png (Portable Network Graphics – переносимая сетевая
графика) и .jpg (Joint Photographic Experts Group – объединенная экспертная группа по фотографии). Пакеты поддержки дополнительных форматов изображений доступны на сайте godashboard.
appspot.com/project. Функция jpeg.Encode() имеет дополнительный
аргумент, который можно использовать для тонкой настройки параметров сохранения изображения – здесь в этом аргументе передается nil, что соответствует настройкам по умолчанию.

Эти функции кодирования могут возбуждать аварийную ситуацию, например если вместо значения типа image.Image передать nil.
Поэтому, чтобы защитить программу от ошибок, можно было бы
предусмотреть отложенный вызов функции, вызывающей функцию
recover() , либо в этой функции, либо в одной из вызывающих функций (§5.5.1). Здесь было решено не добавлять такую защиту, потому
что контрольные тесты (здесь не показаны) производят достаточное
количество вызовов функции, и можно с уверенностью сказать, что
ошибка проявится при первом же тестировании и вызовет аварийное завершение программы. Поэтому ее практически невозможно
будет пропустить.

Благодаря поддержке интерфейса draw.Image можно определять
значения изображений, позволяющие изменять цвет отдельных
пикселей. С помощью функции DrawShapes() можно рисовать фигуры (значения, реализующие интерфейс Shaper или Drawer) в таких
изображениях. А вызовом функции SaveImage() можно сохранять
изображения на диске. Помимо этих вспомогательных функций,
нам необходимо определить интерфейсы (такие как Shaper, Drawer
и др.), а также конкретные типы с их методами реализации интерфейсов.

### 6.5.2.2. Иерархия встроенных интерфейсов

Программисты с опытом обычного объектно-ориентированного
программирования на основе наследования наверняка предпочтут
использовать встроенные интерфейсы для создания их иерархии.
Рекомендуемый же способ основан на композиционной модели, которая будет рассматриваться в следующем подподразделе, а здесь
мы познакомимся с иерархической моделью, реализованной в пакете shapes1/shapes.

{% highlight go %}
type Shaper interface {
	Fill() color.Color
	SetFill(fill color.Color)
	Draw(img draw.Image, x, y int) error
}
type CircularShaper interface {
	Shaper // Fill(); SetFill(); Draw()
	Radius() int
	SetRadius(radius int)
}
type RegularPolygonalShaper interface {
	CircularShaper // Fill(); SetFill(); Draw(); Radius(); SetRadius()
	Sides() int
	SetSides(sides int)
}
{% endhighlight %}

Здесь путем встраивания, не наследования, создается иерархия из
трех интерфейсов , определяющих методы для фигур.

Интерфейс Shaper определяет методы для получения и изменения цвета заливки – значений типа color.Color, а также метод
рисования фигуры в заданной позиции в изображении draw.Image.
Интерфейс CircularShaper встраивает интерфейс Shaper, а также
добавляет методы получения и изменения значения радиуса типа
int. Аналогично интерфейс RegularPolygonalShaper встраивает интерфейс CircularShaper (и через него интерфейс Shaper) и добавляет
методы получения и изменения числа сторон типа int.

Несмотря на то что подход на основе создания иерархий, подобных этой, может быть многим знаком и дает положительные результаты, тем не менее это не самый лучший способ решения задач на
языке Go. Причина в том, что такой подход запирает программиста
в рамках иерархии, даже когда в иерархии нет никакой необходимости: в действительности здесь необходимо лишь обеспечить реализацию подходящих интерфейсов в фигурах. Это даст больше гибкости,
как будет показано в следующем подподразделе.

### 6.5.2.3. Свободно компонуемые независимые интерфейсы

В фигурах основной интерес представляют операции, которые можно выполнять над ними (рисование, получение/изменение цвета заливки, получение/изменение величины радиуса и т. д.), обладающие
некоторой долей универсальности. Ниже представлены интерфейсы,
объявленные в пакете shapes2/shapes, реализующем композиционный подход.

{% highlight go %}
type Shaper interface {
	Drawer // Draw()
	Filler // Fill(); SetFill()
}
type Drawer interface {
	Draw(img draw.Image, x, y int) error
}
type Filler interface {
	Fill() color.Color
	SetFill(fill color.Color)
}
type Radiuser interface {
	Radius() int
	SetRadius(radius int)
}
type Sideser interface {
	Sides() int
	SetSides(sides int)
}
{% endhighlight %}

Интерфейс Shaper в этом пакете демонстрирует простой способ
определения обобщенной фигуры, то есть фигуры, которую можно нарисовать и которая позволяет получить/изменить цвет заливки. Все
остальные интерфейсы определяют более специализированные особенности (получение и изменение дополнительных параметров фигур).

Множество независимых интерфейсов обеспечивают большую
гибкость, чем их иерархия. Например, при использовании функции DrawShapes() можно более точно определять передаваемые ей
фигуры, чем это было возможно в иерархической модели. Кроме
того, в отсутствие иерархии можно более свободно добавлять другие
интерфейсы и, конечно же, при наличии множества узкоспециализированных интерфейсов их проще компоновать для достижения
требуемого результата, как это видно на примере интерфейса Shaper.

Две разные версии пакета shapes имеют совершенно отличные интерфейсы (даже при том, что в обоих имеется интерфейс Shaper, их
тела совершенно отличаются). Тем не менее, поскольку интерфейсы
и конкретные типы полностью независимы друг от друга, эти различия практически не оказывают влияния на конкретную реализацию
интерфейсов.

### 6.5.2.4. Конкретные типы и методы

Это последний подподраздел с описанием пакета shapes – здесь будут представлены конкретные реализации интерфейсов, описанных
в двух предыдущих подподразделах.

{% highlight go %}
type shape struct{ fill color.Color }
func newShape(fill color.Color) shape {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	return shape{fill}
}
func (shape shape) Fill() color.Color { 
	return shape.fill 
}
func (shape *shape) SetFill(fill color.Color) {
	if fill == nil { // Значение nil цвета просто интерпретируется как черный цвет
		fill = color.Black
	}
	shape.fill = fill
}
{% endhighlight %}

Этот простой тип является неэкспортируемым, поэтому он доступен только внутри пакета shapes. То есть значение типа shape не
может быть создано за пределами пакета.

В иерархическом пакете shaper1/shapes этот тип не реализует ни
один из интерфейсов из-за отсутствия метода Draw(). Но в композиционном пакете shaper2/shapes он реализует интерфейс Filler.

В программном коде только тип Circle (который рассматривается
чуть ниже) встраивает интерфейс shape непосредственно. Поэтому
теоретически в тип Circle можно было бы добавить поле типа color.
Color, реализовать методы получения и изменения цвета, принимающие приемник типа *Circle вместо типа *shape и полностью избавиться от типа shape. Однако для большей гибкости лучше оставить
тип shape, потому что это упрощает добавление дополнительных интерфейсов и типов фигур, которые могут основываться непосредственно на типе shape (то есть иметь цвет), а не на типе Circle (например, из-за неприменимости к ним понятия радиус). Эта гибкость еще пригодится при выполнении одного из упражнений.


{% highlight go %}
type Circle struct {
	shape
	radius int
}
func NewCircle(fill color.Color, radius int) *Circle {
	return &Circle{newShape(fill), saneRadius(radius)}
}
func (circle *Circle) Radius() int {
	return circle.radius
}
func (circle *Circle) SetRadius(radius int) {
	circle.radius = saneRadius(radius)
}
func (circle *Circle) Draw(img draw.Image, x, y int) error {
// ... около 30 строк ...
}
func (circle *Circle) String() string {
	return fmt.Sprintf("circle(fill=%v, radius=%d)", circle.fill, circle.radius)
}
{% endhighlight %}

Это полная реализация типа Circle. Несмотря на возможность
создавать значения конкретного типа *Circle, их можно передавать как интерфейсы, что обеспечивает значительную гибкость.
Например, функция DrawShapes() принимает значения, реализующие интерфейс Shaper (или Drawer), независимо от их конкретного типа.

В иерархическом пакете shaper1/shapes этот тип реализует интерфейсы CircularShaper и Shaper. В композиционном пакете shaper2/
shapes он реализует интерфейсы Filler, Radiuser, Drawer и Shaper. И
в обоих пакетах этот тип также реализует интерфейс fmt.Stringer.

Поскольку в языке Go отсутствуют конструкторы типов и в определении типа имеются неэкспортируемые поля, необходимо реализовать функцию-конструктор, которая должна вызываться явно.
Функция-конструктор для типа Circle называется NewCircle() –
далее можно будет увидеть, что в пакете имеется также функция
New(), способная создавать значения любых типов фигур из пакета
shapes. Вспомогательная функция saneRadius(), созданная выше,
возвращает переданное ей целое число, если оно попадает в заданный диапазон, в противном случае – ближайшее граничное значение
диапазона.

Реализация метода Draw() была опущена (ее можно найти в загружаемых примерах к книге), так как основной интерес в этой главе
представляют интерфейсы и типы, а не приемы работы с графикой.


{% highlight go %}
type RegularPolygon struct {
	*Circle
	sides int
}
func NewRegularPolygon(fill color.Color, radius, sides int) *RegularPolygon {
	return &RegularPolygon{NewCircle(fill, radius), saneSides(sides)}
}
func (polygon *RegularPolygon) Sides() int {
	return polygon.sides
}
func (polygon *RegularPolygon) SetSides(sides int) {
	polygon.sides = saneSides(sides)
}
func (polygon *RegularPolygon) Draw(img draw.Image, x, y int) error {
// ... примерно 55 строк, включая две вспомогательные функции ...
}
func (polygon *RegularPolygon) String() string {
	return fmt.Sprintf("polygon(fill=%v, radius=%d, sides=%d)",	polygon.Fill(), polygon.Radius(), polygon.sides)
}
{% endhighlight %}

Это полная реализация типа RegularPolygon, представляющего обычные многоугольники. Этот тип очень похож на тип Circle, только имеет
более сложную реализацию метода Draw() (тело которого было опущено). Поскольку тип RegularPolygon встраивает тип *Circle, часть его
полей заполняется с помощью функции NewCircle() (выполняющей
необходимые проверки). Вспомогательная функция saneSides() действует точно так же, как функции saneRadius() и saneLength().

В иерархическом пакете shaper1/shapes этот тип реализует интерфейсы RegularPolygonalShaper, CircularShaper, Shaper и fmt.Stringer.
В композиционном пакете shaper2/shapes он реализует интерфейсы
Filler, Radiuser, Sideser, Drawer, Shaper и fmt.Stringer.

Функции NewCircle() и NewRegularPolygon() позволяют создавать
значения типов *Circle и *RegularPolygon, а поскольку эти типы реализуют интерфейс Shaper и другие, их значения можно передавать
как реализующие интерфейс Shapers или другие интерфейсы. Относительно таких значений можно вызывать любые методы интерфейса Shaper (то есть Fill(), SetFill() и Draw()). А если для значения
типа Shaper потребуется вызвать метод, не принадлежащий интерфейсу Shaper, с помощью операции приведения типа или выбора
по типу можно будет получить доступ к значению как к значению,
реализующему требуемый интерфейс. Пример такого подхода будет
показан ниже, при знакомстве с функциями showShapeDetails().

Легко можно представить, что впоследствии может потребоваться
определить другие типы фигур, из которых одни будут основаны на
типе shape, другие – на типах Circle и RegularPolygon. Кроме того,
могут возникнуть ситуации, когда потребуется создавать фигуры,
форма которых определяется во время выполнения, например в виде названия фигуры. Для этой цели можно создать фабричную функцию , то есть функцию, возвращающую значения фигур, конкретный
тип которых зависит от аргумента.

{% highlight go %}
type Option struct {
	Fill color.Color
	Radius int
}
func New(shape string, option Option) (Shaper, error) {
	sidesForShape := map
	map[string]int{"triangle": 3, "square": 4,
	"pentagon": 5, "hexagon": 6, "heptagon": 7, "octagon": 8,
	"enneagon": 9, "nonagon": 9, "decagon": 10}
	if sides, found := sidesForShape[shape]; found {
		return NewRegularPolygon(option.Fill, option.Radius, sides), nil
	}
	if shape != "circle" {
		return nil, fmt.Errorf("shapes.New(): invalid shape ‘%s’", shape)
	}
	return NewCircle(option.Fill, option.Radius), nil
}
{% endhighlight %}


Эта фабричная функция принимает два аргумента: название фигуры, которую требуется создать, и значение типа Option с дополнительными параметрами фигуры. (Об использовании структур для
поддержки необязательных аргументов рассказывалось в главе 5, в
§5.6.1.3.) Функция возвращает фигуру, реализующую интерфейс
Shaper и значение nil или, если указано недопустимое название фигуры, nil и значение ошибки. (Напомню, что интерфейс Shaper в
разных пакетах shapes объявлен по-разному, §6.5.2.2 и §6.5.2.3.) Выбор того или иного типа фигуры производится на основе аргумента
shape с названием фигуры. Здесь нет необходимости проверять цвет
или радиус, потому что эти проверки будут выполнены методом
shapes.shape.SetFill() и функцией shapes.saneRadius(), которые
в конечном итоге будут вызваны методами NewRegularPolygon() и
NewCircle(). То же касается и количества сторон.



{% highlight go %}
polygon := shapes.NewRegularPolygon(color.RGBA{0, 0x7F, 0, 0xFF}, 65, 4)
showShapeDetails(polygon) X
y = 30
for i, radius := range []int{60, 55, 50, 45, 40} {
	polygon.SetRadius(radius)
	polygon.SetSides(i + 5)
	x += radius
	y += height / 8
	if err := shapes.DrawShapes(img, x, y, polygon); err != nil {
		fmt.Println(err)
	}
}
{% endhighlight %}

Этот короткий фрагмент демонстрирует, как с помощью функции
DrawShapes() создавались некоторые многоугольники, изображенные
на рис. 6.3 (выше). Функция showShapeDetails() (X в листинге выше) используется для вывода информации о фигурах любых типов.
Это возможно благодаря тому, что функция принимает любые значения, реализующие интерфейс Shaper (то есть любые фигуры),
а не значения конкретных типов фигур (таких как *Circle или
*RegularPolygon).

Поскольку в двух пакетах shapes интерфейс Shaper объявлен поразному, имеются две разные реализации функции showShapeDetails().
Ниже показана реализация из иерархической версии пакета shaper1/
shapes.

---------------------------------Встраивание – это не наследование
В этом подразделе на примере пакета shaper демонстрируется, как
можно использовать прием встраивания для достижения эффекта,
напоминающего наследование . Этот прием может показаться привлекательным для тех, кто занимается переносом программ с языка
C++ или Java на язык Go (или программистам с опытом работы на
C++ или Java, изучающим язык Go). Однако хотя этот прием дает
положительные результаты, тем не менее в программах на языке Go
следует не имитировать наследование, а вообще избегать его.
В контексте примера это означает необходимость создания независимых структур:

{% highlight go %}
type Circle struct {
	color.Color
	Radius int
}

type RegularPolygon struct {
	color.Color
	Radius int
	Radius int
}
{% endhighlight %}

Такой подход все еще позволяет передавать обобщенные значения,
представляющие фигуры. В конце концов, если обе фигуры имеют
методы Draw() , реализующие интерфейс Drawer , значит, значения
обоих типов, Circle и RegularPolygon, можно передавать как значения типа Drawer .

Важно также отметить, что все поля здесь объявлены экспортируемыми и без поддержки проверки их значений. Это означает, что
их значения должны проверяться в момент использования, а не в
момент изменения. В принципе, оба подхода к контролю допустимости значений хороши: выбор того или иного зависит от конкретных
требований.

Представленные выше структуры используются в примере shaper3 ,
который обладает той же функциональностью, что и примеры shaper1
и shaper2 , обсуждаемые в этом разделе. Однако пакет shaper3 написан в более характерном для языка Go стиле, без встраивания и с
реализацией проверки значений полей в момент их использования.
---------------------------------

{% highlight go %}
func showShapeDetails(shape shapes.Shaper) {
	fmt.Print("fill=", shape.Fill(), " ") // Все фигуры имеют цвет заливки
	if shape, ok := shape.(shapes.CircularShaper); ok { // затеняющая переменная
		fmt.Print("radius=", shape.Radius(), " ")
		if shape, ok := shape.(shapes.RegularPolygonalShaper); ok {// затеняющая
			fmt.Print("sides=", shape.Sides(), " ")
		}
	}
	fmt.Println()
}
{% endhighlight %}

В иерархии интерфейсов, в пакете shaper1/shapes, методы Fill()
и SetFill() определяются интерфейсом Shaper, поэтому они могут
вызываться непосредственно. Но для вызова других методов используется контролируемое приведение типа, чтобы убедиться, что
переданное значение shape реализует необходимые интерфейсы.
Здесь, например, метод Radius() вызывается, только если значение
shape реализует интерфейс CircularShaper. То же касается и метода
Sides(), объявляемого интерфейсом RegularPolygonalShaper. (Напомню, что интерфейс RegularPolygonalShaper встраивает интерфейс
CircularShaper.)

Версия функции showShapeDetails() из пакета shaper2/shapes похожа на версию из пакета shaper1/shapes.


{% highlight go %}
func showShapeDetails(shape shapes.Shaper) {
	fmt.Print("fill=", shape.Fill(), " ") // Все фигуры имеют цвет заливки
	if shape, ok := shape.(shapes.Radiuser); ok { // затеняющая переменная
		fmt.Print("radius=", shape.Radius(), " ")
	}
	if shape, ok := shape.(shapes.Sideser); ok { // затеняющая переменная
		fmt.Print("sides=", shape.Sides(), " ")
	}
	fmt.Println()
}
{% endhighlight %}

Композиционный пакет shaper2/shapes определяет вспомогательный
интерфейс Shaper, встраивающий интерфейсы Drawer и Filler, поэтому
заранее известно, что переданное значение shape имеет метод Fill(). И
в отличие от версии в пакете shaper1/shapes, здесь можно использовать
более специализированные операции приведения типа для доступа к
методам Radius() и Sides() фигур, реализующих их.

Если в тип shape, Circle или RegularPolygon добавить новые поля или методы, это не потребует вносить изменения в существующий программный код. Но если добавить новые методы в любой
из интерфейсов, придется реализовать их в соответствующих типах
фигур, иначе программный код не будет работать. Более удачное
решение состоит в том, чтобы объявить новые интерфейсы с дополнительными методами и встроить в них существующие интерфейсы.
Это не нарушит работу имеющегося программного кода и даст возможность выбирать – добавлять или не добавлять реализацию новых методов в существующие типы, в зависимости от необходимости реализации новых интерфейсов вдобавок к уже реализованным.

При работе с интерфейсами рекомендуется применять композиционный подход, а не иерархический. Что касается структур, рекомендуется использовать прием, характерный для языка Go, то есть создавать независимые структуры и не пытаться имитировать наследование.
Разумеется, после обретения достаточного опыта такой выбор будет
производиться, исходя из культуры программирования на языке Go, а
не на основе простоты переноса с других языков или из-за привычки.

В дополнение к примерам shaper1 и shaper2, представленным в
этом подразделе, в загружаемых примерах к книге имеется также
пример shaper3, демонстрирующий «чистокровный» способ реализации на языке Go. Версия shaper3 имеет всего один интерфейс, Drawer,
и независимые структуры Circle и RegularPolygon (как показано во
врезке «Встраивание – это не наследование» выше). Кроме того, в
версии shaper3 используются фактические значения типа shape, а не
указатели, а проверка значений полей выполняется в момент их использования. Обязательно загляните в файлы shaper2/shapes/shapes.
go и shaper3/shapes/shapes.go и сравните эти два подхода.


## 6.5.3. Пример: упорядоченное отображение – обобщенный тип коллекций

В последнем примере для этой главы представлен обобщенный тип
упорядоченных отображений, который хранит пары ключ/значение
подобно встроенному типу map, но все пары хранятся в порядке
следования ключей. В реализации упорядоченного отображения
используется левостороннее красно-черное дерево, благодаря чему
достигается высокая скорость работы, где алгоритм поиска имеет
сложность O(log 2 n) (2) . Для сравнения, производительность алгоритма на основе несбалансированных двоичных деревьев может
ухудшаться до производительности алгоритма работы со связанными списками (O(n)), если элементы добавляются по порядку.
Сбалансированные деревья не страдают от этого дефекта, потому
что они поддерживают сбалансированность при добавлении и удалении элементов, благодаря чему сохраняется высокая производительность.

Программисты с опытом объектно-ориентированного программирования на основе наследования (на таких языках, как C++, Java,
Python) наверняка решат заставить ключи упорядоченного отображения поддерживать оператор сравнения < или метод Less(другой_
ключ) bool. Этого легко можно добиться, определив интерфейс Lesser, требующий реализации такого метода, и объявив типы-обертки
для типов int, string, MyType и т. д., реализующие этот метод. Однако
в языке Go используется несколько иной подход.
В данной реализации упорядоченных отображений не накладывается ограничений на тип ключей. Вместо этого каждое отображение
будет снабжаться функцией «меньше чем» для сравнения ключей.
То есть совершенно не важно, будут ли поддерживать ключи оператор < или нет, – главное, чтобы имелась подходящая функция,
способная сравнивать их.

Прежде чем приступить к обсуждению реализации, рассмотрим
несколько примеров ее использования, начав с создания и заполнения упорядоченного отображения.

{% highlight go %}
words := []string{"Puttering", "About", "in", "a", "Small", "Land"}
wordForWord := omap.NewCaseFoldedKeyed()
for _, word := range words {
	wordForWord.Insert(word, strings.ToUpper(word))
}
{% endhighlight %}

Реализация упорядоченного отображения находится в пакете omap
в виде типа Map. Чтобы создать значение типа Map необходимо вызвать
функцию omap.New() или любую другую функцию-конструктор, возвращающую значение типа Map, такую как omap.NewCaseFoldedKeyed(),
использованную здесь, потому что нулевое значение типа Map непригодно к использованию. Данная конкретная функция-конструктор
создает пустое отображение типа Map с предопределенной функцией
сравнения строковых ключей без учета регистра символов и возвращает указатель (то есть значение типа *Map).

Каждая пара ключ/значение добавляется с помощью метода omap.
Map.Insert(), принимающего два значения типа interface{} , то есть
ключ и значение любых типов. (Однако тип ключа должен быть
совместим с функцией сравнения, поэтому в данном примере используются строковые ключи.) Метод Insert() возвращает true, если новый элемент был успешно вставлен, и false – если элемент с
указанным ключом уже существует (в этом случае существующее
значение элемента замещается новым значением – точно так же действует и встроенный тип map).

{% highlight go %}
wordForWord.Do(func(key, value interface{}) {
fmt.Printf("%v -> %v\n", key, value)
})
______________
a -> A
About -> ABOUT
in -> IN
Land -> LAND
Puttering -> PUTTERING
Small -> SMALL
{% endhighlight %}

Метод omap.Map.Do() принимает функцию с сигнатурой
func(interface{}, interface{}) и вызывает ее для каждого элемента
в упорядоченном отображении, в порядке следования ключей, передавая ключи и значения в виде аргументов. Здесь метод Do() был
использован для вывода всех ключей и значений в отображении
wordForWord.

Помимо добавления элементов и вызова функции для каждого элемента в отображении, имеется также возможность получать
количество элементов, отыскивать требуемые элементы и удалять
элементы.





{% highlight go %}
fmt.Println("length before deleting:", wordForWord.Len())
_, containsSmall := wordForWord.Find("small")
fmt.Println("contains small:", containsSmall)
for _, key := range []string{"big", "medium", "small"} {
	fmt.Printf("%t ", wordForWord.Delete(key))
}
_, containsSmall = wordForWord.Find("small")
fmt.Println("\nlength after deleting: ", wordForWord.Len())
fmt.Println("contains small:", containsSmall)
______________________
length before deleting: 6
contains small: true
false false true
length after deleting: 5
contains small: false
{% endhighlight %}

Метод omap.Map.Len() возвращает количество элементов в упорядоченном отображении.

Метод omap.Map.Find() возвращает значение элемента с указанным ключом в виде значения типа interface{} и true, или nil и
false, если искомый элемент отсутствует. Метод omap.Map.Delete()
удаляет элемент с указанным ключом и возвращает true. Если требуемый элемент отсутствует в отображении, метод ничего не делает
и возвращает false.

Если потребуется использовать ключи пользовательского типа,
это можно сделать, создав отображение типа Map с помощью функции omap.New() и реализовав соответствующий метод сравнения.

Например, ниже приводится реализация очень простого пользовательского типа.


{% highlight go %}
type Point struct{ X, Y int }
func (point Point) String() string {
	return fmt.Sprintf("(%d, %d)", point.X, point.Y)
}
{% endhighlight %}

Теперь посмотрим, как создать упорядоченное отображение с
ключами типа *Points и значениями, определяющими расстояние
от начала координат.

В следующем фрагменте создается пустое отображение типа Map,
которому передается функция сравнения ключей *Point. Затем создается срез со значениями *Points и выполняется заполнение отображения. И наконец, с помощью метода omap.Map.Do() выводятся
ключи и значения, хранящиеся в отображении, в порядке следования ключей.

{% highlight go %}
distanceForPoint := omap.New(func(a, b interface{}) bool {
	D, E := a.(*Point), b.(*Point)
	if D.X != E.X {
	return D.X < E.X
	}
	return D.Y < E.Y
})
points := []*Point{{'{{'|escape}}3, 1}, {1, 2}, {2, 3}, {1, 3}, {3, 2}, {2, 1}, {2, 2}}
for _, point := range points {
	distance := math.Hypot(float64(point.X), float64(point.Y))
	distanceForPoint.Insert(point, distance)
}
distanceForPoint.Do(func(key, value interface{}) {
	fmt.Printf("%v -> %.2v\n", key, value)
})
_____________________
(1, 2) -> 2.2
(1, 3) -> 3.2
(2, 1) -> 2.2
(2, 2) -> 2.8
(2, 3) -> 3.6
(3, 1) -> 3.2
(3, 2) -> 3.6
{% endhighlight %}

В главе 4 (§4.2.2) упоминалось, что компилятор Go позволяет
не указывать тип элементов и знак амперсанда при создании литералов врезов, поэтому здесь определение среза points в действительности является сокращенной формой инструкции points :=
[]*Point{&Point{3, 1}, &Point{1, 2}, ...}.

Хотя здесь и не показано, тем не менее для отображения distanceForPoint можно вызывать методы Delete(), Find() и Len(), как было
показано в примере с отображением wordForWord выше, но передавая
первым двум ключи типа *Point (потому что функция сравнения
принимает значения типа *Point, а не Point).

Теперь, когда было показано, как использовать упорядоченное
отображение, можно перейти к знакомству с его реализацией. Здесь
не будут рассматриваться вспомогательные методы и функции, используемые методом Delete(), потому что некоторые из них достаточно сложны и их изучение не добавит новых знаний о программировании на языке Go. (Все эти функции можно найти в загружаемых примерах к книге, в файле qtrac.eu/omap/omap.go.) Знакомство
начнется с представления двух типов, используемых для реализации
упорядоченного отображения (Map и node), и функций-конструкторов. Затем будут рассмотрены методы типа Map и некоторые вспомогательные функции. Как это принято при программировании на
языке Go, большинство методов очень короткие, и всю основную
работу выполняют вспомогательные функции.



{% highlight go %}
type Map struct {
	root *node
	less func(interface{}, interface{}) bool
	length int
}
type node struct {
	interface{}
	key, value interface
	red
	bool
	left, right *node
}
{% endhighlight %}

Реализация упорядоченных отображений основана на двух пользовательских типах. Первый тип, Map, хранит корень левостороннего
красно-черного дерева, функцию для сравнения ключей и количество элементов в отображении. Все поля в этом типе являются неэкспортируемыми, и нулевым значением для поля less является значение nil, поэтому при создании переменной типа Map будет создано
недопустимое отображение типа Map. Эта особенность отмечена в
документации к типу Map, где пользователям рекомендуется использовать одну из функций-конструкторов, имеющихся в пакете omap.

Второй тип, node, представляет единственный элемент ключ/значение. Кроме соответствующих полей key и value, тип node имеет три
дополнительных поля, необходимых для реализации дерева. Поле
red типа bool используется для идентификации узла как «красного» (true) или «черного» (false) – оно используется при вращении
фрагментов дерева для поддержания сбалансированности. Поля left
и right типа *node хранят указатели на левое и правое поддеревья
(которые могут иметь значением nil).

В пакете omap имеются несколько функций-конструкторов. Здесь
будет показана универсальная функция omap.New() и пара более специализированных.

{% highlight go %}
func New(less func(interface{}, interface{}) bool) *Map {
	return &Map{less: less}
}
{% endhighlight %}

Эта универсальная функция может использоваться для создания
упорядоченных отображений с ключами и значениями любых встроенных и пользовательских типов, для которых будет предоставлена
соответствующая функция сравнения.

{% highlight go %}
func NewCaseFoldedKeyed() *Map {
	return &Map{less: func(a, b interface{}) bool {
		return strings.ToLower(a.(string)) < strings.ToLower(b.(string))
	}}
}
{% endhighlight %}

Эта функция-конструктор создает пустое упорядоченное отображение со строковыми ключами, которые сравниваются без учета
регистра символов.

{% highlight go %}
func NewIntKeyed() *Map {
	return &Map{less: func(a, b interface{}) bool {
		return a.(int) < b.(int)
	}}
}
{% endhighlight %}

Эта функция-конструктор создает пустое упорядоченное отображение с ключами типа int.

В пакете omap имеется также функция omap.NewStringKeyed() для
создания упорядоченных отображений со строковыми ключами, которые сравниваются с учетом регистра символов (ее реализация практически идентична функции omap.NewCaseFoldedKeyed(), но в ней отсутствует вызов strings.ToLower()), и функция omap.NewFloat64Keyed(),
действующая подобно функции omap.NewIntKeyed(), за исключением
того, что в ней используются значения типа float64 вместо int.

{% highlight go %}
func (m *Map) Insert(key, value interface{}) (inserted bool) {
	m.root, inserted = m.insert(m.root, key, value)
	m.root.red = false
	if inserted {
		m.length++
	}
	return inserted
}
{% endhighlight %}

По своей структуре этот метод является типичным для языка Go,
так как основную работу он выполняет с помощью вспомогательной
функции, в данном случае – неэкспортируемого метода insert().
При добавлении новых элементов корень дерева может изменяться
либо в результате добавления первого узла в пустое дерево, которое
становится его корнем, либо в результате вращений, вовлекающих
корень, чтобы сохранить дерево сбалансированным.

Метод insert() возвращает корень дерева независимо от того, изменился он или нет, а также логическое значение. Если элемент был
добавлен в отображение, возвращается логическое значение true, и в
этом случае увеличивается длина отображения. Если в логическом
значении возвращается false, это означает, что элемент с данным
ключом уже имеется в отображении, и значение этого элемента было замещено текущим значением value, поэтому длина отображения не изменяется. (Здесь не будет объясняться, почему узлы могут
быть «красными» или «черными» или почему они могут вращаться.
Все это подробно объясняется в статьях Роберта Седжвика (Robert
Sedgewick), упоминавшихся в сноске выше.)

{% highlight go %}
func (m *Map) insert(root *node, key, value interface{}) (*node, bool) {
	inserted := false
	if root == nil { // Если ключ должен быть вставлен в дерево, то сюда
		return &node{key: key, value: value, red: true}, true
	}
	if isRed(root.left) && isRed(root.right) {
		colorFlip(root)
	}
	if m.less(key, root.key) {
		root.left, inserted = m.insert(root.left, key, value)
	} else if m.less(root.key, key) {
		root.right, inserted = m.insert(root.right, key, value)
	} else { // Ключ уже имеется в дереве, поэтому просто сохранить новое значение
		root.value = value
	}
	if isRed(root.right) && !isRed(root.left) {
		root = rotateLeft(root)
	}
	if isRed(root.left) && isRed(root.left.left) {
		root = rotateRight(root)
	}
	return root, inserted
}
{% endhighlight %}

Эта рекурсивная функция выполняет обход дерева в поисках узла
с искомым ключом и при необходимости вращает поддеревья, чтобы
обеспечить сбалансированность. Когда метод Insert() вызывает этот
метод, он передает корень всего дерева (или nil, если дерево не имеет узлов), но в последующих рекурсивных вызовах в аргументе root
передается корень поддерева (который может иметь значение nil).

Если новый ключ не будет найден в дереве, в процессе обхода будет
достигнут правый крайний его лист для вставки нового ключа – лист
со значением nil. В этом случае создается новое значение типа *node
для текущего листа, в котором оба указателя на собственные листы
имеют значение nil. Здесь не требуется явно инициализировать поля
left и right нового узла (то есть его листы), потому что компилятор
Go автоматически присвоит им соответствующие нулевые значения
(nil), поэтому для инициализации полей структуры с ненулевыми
значениями здесь используется синтаксис ключ: значение.

Если новый ключ совпадает с одним из ключей в отображении,
используется существующий узел и его значение просто замещается
новым значением. (Как и в отображениях встроенного типа map.)
Как следствие этого каждый элемент в упорядоченном отображении
будет иметь уникальный ключ.

{% highlight go %}
func isRed(root *node) bool { return root != nil && root.red }
{% endhighlight %}

Эта маленькая вспомогательная функция позволяет узнать, является ли данный узел «красным». Значение nil интерпретируется
как «черный» узел.

{% highlight go %}
func colorFlip(root *node) {
	root.red = !root.red
	if root.left != nil {
		root.left.red = !root.left.red
	}
	if root.right != nil {
		root.right.red = !root.right.red
	}
}
{% endhighlight %}

Эта вспомогательная функция изменяет цвет указанного узла и
цвет его листьев на противоположный.

{% highlight go %}
func rotateLeft(root *node) *node {
	x := root.right
	root.right = x.left
	x.left = root
	x.red = root.red
	root.red = true
	return x
}

func rotateRight(root *node) *node {
	x := root.left
	root.left = x.right
	x.right = root
	x.red = root.red
	root.red = true
	return x
}
{% endhighlight %}

Эти функции выполняют вращение поддеревьев указанного корня, чтобы поддержать их сбалансированность.

{% highlight go %}
func (m *Map) Find(key interface
	interface{}) (value interface{}, found bool) {
	root := m.root
	for root != nil {
		if m.less(key, root.key) {
			root = root.left
		} else if m.less(root.key, key) {
			root = root.right
		} else {
			return root.value, true
		}
	}
	return nil, false
}
{% endhighlight %}

Поскольку данный метод достаточно прост в реализации и вместо рекурсии использует итерации, нет нужды создавать для него
вспомогательную функцию.

Метод Find() отыскивает элемент, сравнивая искомый ключ с текущим корневым узлом (в процессе обхода дерева) с помощью функции
less(). Делается это с использованием логического тождества x = y 
2 (x < y ɇ y < x). Она действительна для целых и вещественных
чисел, строк, пользовательского типа Point и многих других, но справедлива не для всех типов. При необходимости тип omap.Map легко
можно было бы расширить, добавив в него отдельную функцию сравнения, возвращающую true в случае равенства сравниваемых ключей.

Обратите внимание, что здесь используются именованные возвращаемые значения , хотя им явно ничего не присваивается. Разумеется,
значения им неявно будут присвоены в инструкциях return. Именованные значения, как в данном случае, могут пригодиться для нужд
документирования функции или метода. Здесь, например, из сигнатуры Find(key interface{}) (value interface{}, found bool) видно, что
возвращает метод – определить это было бы намного сложнее, если
бы метод имел сигнатуру Find(key interface{}) (interface{}, bool).

{% highlight go %}
func (m *Map) Delete(key interface{}) (deleted bool) {
	if m.root != nil {
		if m.root, deleted = m.remove(m.root, key); m.root != nil {
			m.root.red = false
		}
	}
	if deleted {
		m.length-	}
	return deleted
}
{% endhighlight %}

Удаление элемента из левостороннего красно-черного дерева является достаточно сложной процедурой, поэтому вся основная работа перекладывается на вспомогательный неэкспортируемый метод
remove() и на вспомогательную функцию, используемую им (здесь
не показаны). Если упорядоченное отображение не содержит элементов или если ни один из элементов не соответствует искомому
ключу, метод Delete() просто ничего не делает и возвращает false.
Если дерево состоит из единственного элемента и этот элемент требуется удалить, тогда в корень приемника *omap.Map сохраняется
значение nil (и дерево становится пустым). Если удаление было
выполнено, длина отображения уменьшается на единицу и вызывающей программе возвращается true.

Метод remove() отыскивает элемент для удаления, используя то
же тождество, что и метод Find().

{% highlight go %}
func (m *Map) Do(function func(interface{}, interface{})) {
	do(m.root, function)
}
func do(root *node, function func(interface{}, interface{})) {
	if root != nil {
		do(root.left, function)
		function(root.key, root.value)
		do(root.right, function)
	}
}
{% endhighlight %}

Метод Do() и его вспомогательная функция do() используются
для обхода всех элементов в упорядоченном отображении, в порядке
следования ключей, и вызывают указанную функцию для каждого
элемента, передавая его ключ и значение в виде аргументов.

{% highlight go %}
func (m *Map) Len() int {
return m.length
}
{% endhighlight %}

Этот метод просто возвращает длину отображения. Длина увеличивается и уменьшается в методах omap.Map.Insert() и omap.Map.
Delete(), представленных выше.

На этом завершаются обзор пользовательского типа упорядоченных коллекций и знакомство с особенностями объектно-ориентированного программирования на языке Go.

Когда дело доходит до пользовательских типов, для которых любые
значения являются допустимыми, можно просто объявить тип (например, в виде структуры) и сделать сам тип и все его поля экспортируемыми (присвоив им имена, начинающиеся с заглавных букв).
Этого будет вполне достаточно. (В качестве примеров можно указать
типы image.Point и image.Rectangle в стандартной библиотеке.)

Для пользовательских типов, требующих проверки (например, для
составных типов с одним или более полей, где хотя бы одно поле
требует проверки присваиваемых ему значений), в языке Go имеется
характерная идиома программирования. Поля, требующие проверки,
делаются неэкспортируемыми (им присваиваются имена, начинающиеся с маленькой буквы), и реализуются методы доступа к ним.

В случае типов, для которых нулевые значения являются недопустимыми, соответствующие поля делаются неэкспортируемыми,
и для них реализуются методы доступа. Факт недопустимости нулевых значений обязательно должен отражаться в документации, и
должны предоставляться экспортируемые функции-конструкторы
(обычно с именем New()). Обычно функции-конструкторы возвращают указатель на значение требуемого типа со всеми полями, заполненными допустимыми значениями.

Значения и указатели на значения с экспортируемыми и неэкспортируемыми полями могут передаваться функциям как обычно,
а в случае, если типы реализуют один или более интерфейсов, они,
разумеется, могут передаваться как интерфейсы, когда это удобно,
то есть когда важно поведение значения, а не его фактический тип.

Очевидно, что программистам с опытом объектно-ориентированного программирования, основанного на наследовании (в таких языках, как C++, Java или Python), придется перестраивать образ своего
мышления. Однако удобства динамической типизации и интерфейсы, поддерживаемые в языке Go, а также отсутствие механизма наследования, причиняющего массу неудобств при сопровождении,
с лихвой окупят усилия, затраченные на их изучение и освоение.
Подход к объектно-ориентированному программированию, используемый в Go, позволяет получить превосходные результаты, если
следовать духу языка Go.


## 6.6. Упражнения

В этой главе предлагается выполнить три упражнения. Первое связано с созданием небольшого, но законченного типа, поля которого
требуют проверки. Второе связано с расширением функциональности одного из типов, рассматривавшихся в этой главе. В третьем
упражнении потребуется создать небольшой тип коллекций. Первые
два упражнения не слишком сложные, но третье упражнение заставит поломать голову.

1. Создайте новый пакет с именем font (например, в файле my_
font/font.go). Цель создания пакета – реализовать тип, представляющий свойства шрифта (такие как название семейства
и размер). В пакете должна присутствовать функция New(),
принимающая название семейства и размер (оба значения
должны проверяться) и возвращающая значение типа *Font (с
допустимыми значениями в неэкспортируемых полях). Также
реализуйте методы чтения и записи с проверкой. При проверке
следует учитывать следующие требования: имя семейства не
должно быть пустой строкой, а размер шрифта должен находиться в диапазоне от 5 до 144 пунктов включительно, при
получении недопустимых значений функции должны устанавливать допустимые значения (или сохранять предыдущие) и
регистрировать проблему в журнале. Не забудьте добавить метод, реализующий интерфейс fmt.Stringer.
Ниже приводится пример создания, изменения и вывода информации о шрифте с помощью пакета.

{% highlight go %}
titleFont := font.New("serif", 11)
titleFont.SetFamily("Helvetica")
titleFont.SetSize(20)
fmt.Println(titleFont)
{font-family: "Helvetica"; font-size: 20pt;}
{% endhighlight %}

Когда пакет будет готов, скопируйте файл font/font_test.go из
загружаемых примеров к книге в каталог my_font и выполните
команду go test, чтобы провести простейшее тестирование.
Пример решения можно найти в файле font/font.go. Весь
пакет занимает примерно 50 строк. В предлагаемом решении
метод String() возвращает информацию о шрифте в виде стиля CSS (Cascading Style Sheet – каскадные таблицы стилей).
В этот пакет достаточно просто, хотя и немного утомительно,
можно добавить обработку всех CSS-атрибутов шрифтов, таких как вес, стиль начертания и видоизменения.


2. Скопируйте весь пример shaper (иерархическую версию
shaper1, композиционную версию shaper2 или версию shaper3,
какая вам больше нравится, но я рекомендую выбрать shaper2
или shaper3, включая подкаталоги) в новый каталог, например my_shaper. Отредактируйте файл my_shaper/shaper[123].
go: удалите из раздела импортирования все модули, оставив
только image и shapes, и удалите все инструкции в функции
main(). Отредактируйте файл my_shaper/shapes/shapes.go, добавив поддержку новой фигуры с именем Rectangle. Эта фигура должна хранить точку рисования, ширину и высоту (все
поля, предоставляемые типом image.Rectangle), цвет заливки
и логический флаг, определяющий необходимость заливки
фигуры. Объявление типа Rectangle должно быть выполнено в том же стиле, что и другие типы фигур, то есть с неэкспортируемыми полями и интерфейсом (например, иерархическим RectangularShaper или композиционными Rectangler
и Filleder) или без интерфейса и экспортируемыми полями
(в стиле, характерном для языка Go), и определите API типа. Метод Draw() реализовать будет несложно, особенно если
воспользоваться неэкспортируемой функцией drawLine(), уже
имеющейся в пакете shapes, и функцией draw.Draw(). Не забудьте также добавить в функцию New() возможность создания
прямоугольников и расширить тип Option.
После добавления типа Rectangle реализуйте в функции main(),
в файле my_shaper/shaper[123].go, создание и сохранение изображения, представленного на рис. 6.4.

!["Рис. 6.4. Изображение, созданное с использованием типа Rectangle"](/images/ris-6-4.jpg "Рис. 6.4. Изображение, созданное с использованием типа Rectangle")

В загружаемых примерах приводятся три возможных решения.
Одно для иерархической версии – в каталоге shaper_ans1, одно
для композиционной версии – в каталоге shaper_ans2, и одно в
стиле языка Go – в каталоге shaper_ans3. Ниже приводится объявление интерфейса RectangularShaper из решения shaper_ans1:

{% highlight go %}
type RectangularShaper interface {
	Shaper // Fill(); SetFill(); Draw()
	Rect() image.Rectangle
	SetRect(image.Rectangle)
	Filled() bool
	SetFilled(bool)
}
{% endhighlight %}

В решении shaper_ans2 имеются два дополнительных интерфейса, Rectangler и Filleder:

{% highlight go %}
type Rectangler interface {
	Rect() image.Rectangle
	SetRect(image.Rectangle)
}
type Filleder interface {
	Filled() bool
	SetFilled(bool)
}
{% endhighlight %}

В решении, реализованном в стиле, характерном для языка Go,
новые интерфейсы создавать не требуется.

В иерархической и композиционной версиях решения используется одно и то же объявление типа Rectangle: с неэкспортируемыми полями и методами доступа. Но в решении,
реализованном в стиле языка Go, используются экспортируемые поля, а проверка выполняется только в месте, где они
используются.

{% highlight go %}
type Rectangle struct {
	color.Color
	image.Rectangle
	Filled bool
}
{% endhighlight %}

В файле shaper_ans1/shapes/shapes.go объявление типа Rectangle и поддерживаемые им методы занимают менее 50 строк.
Еще пара строк потребовалась для расширения типа Option и
пять строк – для расширения функции New(). Новая функция main() в файле shaper_ans1/shaper1.go занимает менее 20
строк. Аналогичные цифры получены в решении shaper_ans2.
В решении shaper_ans3 дополнительного программного кода
получилось меньше.

Наиболее честолюбивые читатели могут попробовать расширить пример еще больше, реализовав отдельную поддержку
цвета для заливки и рамки, где значение nil цвета свидетельствует, что заливка или рамка не должна отображаться, а непустое значение определяет цвет заливки или рамки.


3. Создайте в пакете my_oslice собственный тип коллекций с
именем Slice. Этот тип должен реализовывать упорядоченные срезы. Создайте несколько функций-конструкторов, например функцию New(func(interface{}, interface{}) bool),
принимающую функцию сравнения «меньше чем», и ряд других функций-конструкторов с предопределенными функциями сравнения, таких как NewStringSlice() и NewIntSlice(). Тип
*oslice.Slice должен иметь метод Clear(), очищающий срез,
метод Add(interface{}), вставляющий элемент с учетом упорядочения, метод Remove(interface{}) bool, удаляющий первое
вхождение указанного элемента и сообщающий об успехе или
неудаче, метод Index(interface{}) int, возвращающий индекс первого вхождения указанного элемента (или –1), метод
At(int) interface{}, возвращающий элемент в указанной позиции (и возбуждающий аварийную ситуацию в случае выхода
индекса за границы среза), и метод Len() int, возвращающий
количество элементов в срезе.

{% highlight go %}
func bisectLeft(slice []interface{}, less func(interface interface{}, interface{}) bool, x interface{}) int {
	left, right := 0, len(slice)
	for left < right {
		middle := int((left + right) / 2)
		if less(slice[middle], x) {
			left = middle + 1
		} else {
			right = middle
		}
	}
	return left
}
{% endhighlight %}

В предлагаемом решении используется функция bisectLeft(),
которая может оказаться полезной. Если она возвращает значение len(slice), указанный элемент отсутствует в срезе и при
добавлении должен быть вставлен в конец. Любое другое значение определяет, что либо указанный элемент присутствует
в срезе в данной позиции, либо он отсутствует в срезе и при
добавлении должен быть вставлен в данную позицию.
Желающие могут скопировать файл oslice/oslice_test.go в
каталог my_oslice, чтобы протестировать свое решение. Предлагаемое решение находится в файле oslice/oslice.go и занимает менее 100 строк. Самым сложным является метод Add(),
однако функция InsertStringSlice() из главы 4 (§4.2.3) поможет справиться с этой задачей.

-------------------------
1) В действительности можно было бы возвращать значение типа FuzzyBool
и обеспечить его изменяемость, как показано в примере fuzzy_value , который можно найти в загружаемых примерах к книге.

2) Представленная здесь реализация упорядоченных отображений основана
на левосторонних красно-черных деревьях, описанных Робертом Седжвиком (Robert Sedgewick) в его статьях www.cs.princeton.edu/~rs/talks/
LLRB/LLRB.pdf и www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf.
На момент написания этих строк реализации алгоритмов на языке Java,
представленные в этих статьях, были неполными и содержали ошибки,
поэтому здесь были использованы идеи Ли Станца (Lee Stanza) из его
реализации алгоритма на C++, которую можно найти на сайте www.teachsolaisgames.com/articles/balanced_left_leaning.html.