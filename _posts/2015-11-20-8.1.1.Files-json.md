---
layout: post
title:  "8.1.1. Обработка файлов в формате JSON"
date:   2015-11-20 19:40:00
categories: go
---

* [8.1.1.1. Запись файлов в формате JSON](#json)

* [8.1.1.2. Чтение файлов в формате JSON](#json-1)

Согласно описанию на сайте www.json.org, JSON (JavaScript Object
Notation – форма записи объектов JavaScript) – это легковесный
формат обмена данными, простой для восприятия человеком и простой для обработки программным способом. Формат JSON – это
простой текстовый формат в кодировке UTF-8. Он приобретает все
большую популярность (особенно для передачи данных через сетевые соединения), потому что он более удобный для записи, более
компактный (обычно) и требует меньше вычислительных ресурсов
для парсинга, чем формат XML.

Ниже приводится пример записи одной накладной в формате
JSON (большая часть полей второго пункта накладной опущена).

{% highlight go %}
{
	"Id": 4461,
	"CustomerId": 917,
	"Raised": "2012-07-22",
	"Due": "2012-08-21",
	"Paid": true,
	"Note": "Use trade entrance",
	"Items": [
		{
			"Id": "AM2574",
			"Price": 415.8,
			"Quantity": 5,
			"Note": ""
		},
		{
			"Id": "MI7296",
			...
		}
	]
}
{% endhighlight %}

Обычно инструменты, имеющиеся в пакете encoding/json , выводят данные в формате JSON без лишних пробелов, но здесь были добавлены дополнительные пробелы и отступы, чтобы проще
было охватить ее взглядом. Несмотря на то что пакет encoding/
json поддерживает значения типа time.Time, в данной программе
реализованы собственные методы MarshalJSON() и UnmarshalJSON()
типа Invoice для обработки дат. Это позволило сократить строки
с датами (за счет удаления значения времени, которое в данной
программе всегда равно нулю), например до "2012-09-06" вместо
"2012-09-06T00:00:00Z".

## 8.1.1.1. Запись файлов в формате JSON

Чтобы реализовать методы MarshalInvoices() и UnmarshalInvoices()
для работы с форматом JSON, в программе был определен тип на
основе пустой структуры.

{% highlight go %}
type JSONMarshaler struct{}
{% endhighlight %}

Этот тип реализует обобщенные интерфейсы InvoicesMarshaler и
InvoicesUnmarshaler, представленные выше.

Ниже приводится реализация метода записи полного набора данных типа []*Invoice в значение типа io.Writer в формате JSON с использованием механизмов преобразования, реализованных в пакете
encoding/json. Значение, куда выполняется запись, должно быть
значением типа *os.File, возвращаемым функцией os.Create(),
или значением типа *gzip.Writer, возвращаемым функцией gzip.
NewWriter(), или значением любого другого типа, реализующего
интерфейс io.Writer .

{% highlight go %}
func (JSONMarshaler) MarshalInvoices(writer io.Writer,
    invoices []*Invoice) error {
    encoder := json.NewEncoder(writer)
    if err := encoder.Encode(fileType); err != nil {
        return err
    }
    if err := encoder.Encode(fileVersion); err != nil {
        return err
    }
    return encoder.Encode(invoices)
}
{% endhighlight %}

Тип JSONMarshaler не имеет данных, поэтому нет необходимости
присваивать его значение переменной-приемнику.

Метод начинается с создания значения для преобразования данных в формат JSON, которое обертывает значение, реализующее интерфейс io.Writer, куда можно будет записывать данные для преобразования в формат JSON.

Запись данных выполняется вызовом метода json.Encoder.
Encode() . Этот метод отлично справляется со срезом с накладными,
каждая из которых содержит свой срез с пунктами. Метод возвращает значение ошибки или nil. В случае ошибки она немедленно
возвращается вызывающей программе.

Строго говоря, запись типа файла и версии не является необходимой, но, как иллюстрирует одно из упражнений, это упростит изменение формата файла в будущем (например, в случае добавления
новых полей в структуры Invoice и Item) и обеспечит возможность
чтения файлов обоих форматов, старого и нового.

Обратите внимание, что в этом методе никак не учитываются
типы кодируемых данных, поэтому не составит труда написать
функции для записи других данных, поддерживающих возможность преобразования в формат JSON. Кроме того, для организации записи данных в новом формате не потребуется изменять метод
JSONMarshaler.MarshalInvoices(), при условии что все новые поля
будут экспортируемыми и поддерживающими возможность преобразования в формат JSON.

Если бы в программе не предъявлялось особых требований к преобразованию данных в формат JSON, этого программного кода было
бы вполне достаточно. Однако из-за необходимости более точного
управления выводом данных в формате JSON – в частности, для
форматирования значений типа time.Time – необходимо снабдить
тип Invoice методом MarshalJSON(), реализующим интерфейс json.
Marshaler. Функция json.Encode() автоматически проверяет поддержку интерфейса json.Marshaler преобразуемым значением и при
ее наличии вызывает метод MarshalJSON() преобразуемого значения
вместо встроенной процедуры преобразования.

{% highlight go %}
type JSONInvoice struct {
    Id         int
    CustomerId int
    Raised     string // time.Time in Invoice struct
    Due        string // time.Time in Invoice struct
    Paid       bool
    Note       string
    Items      []*Item
}

func (invoice Invoice) MarshalJSON() ([]byte, error) {
    jsonInvoice := JSONInvoice{
        invoice.Id,
        invoice.CustomerId,
        invoice.Raised.Format(dateFormat),
        invoice.Due.Format(dateFormat),
        invoice.Paid,
        invoice.Note,
        invoice.Items,
    }
    return json.Marshal(jsonInvoice)
}
{% endhighlight %}

Метод Invoice.MarshalJSON() принимает значение типа Invoice и
возвращает его версию в формате JSON. Первая инструкция в методе просто копирует поля накладной в структуру JSONInvoice, преобразуя два значения типа time.Time в строки. Поскольку все поля
в структуре JSONInvoice являются либо логическими, либо числовыми, либо строковыми значениями, она может быть преобразована
в формат JSON с помощью функции json.Marshal() , поэтому здесь
практически всю работу выполняет эта функция.

Для записи даты/времени (то есть значений типа time.Time) в
виде строк необходимо использовать метод time.Time.Format() . Этот
метод принимает строку формата, определяющую, в каком виде
должна быть записана дата/время. Строка формата имеет несколько
необычный вид – она всегда должна быть строковым представлением значения 1136243045 времени Unix, которое точно соответствует дате и времени 2006-01-02T15:04:05Z07:00, или некоторым
подмножеством этой даты и времени. Дата и время здесь выбраны
произвольно, но это значение должно быть фиксированным – никакое другое значение не должно использоваться для определения
форматов даты, времени и даты/времени.

Если потребуется определить другие форматы представления даты/времени, они всегда должны записываться в терминах языка Go.
Например, если потребуется выводить дату в формате: день недели,
месяц, число, год, – следует использовать строку формата, такую как
"Mon, Jan 02, 2006" или "Mon, Jan _2, 2006", если необходимо
подавить вывод ведущих нулей. Полную информацию по этой теме,
а также список некоторых предопределенных строк формата можно
найти в документации к пакету time.

## 8.1.1.2. Чтение файлов в формате JSON

Чтение данных в формате JSON выполняется так же просто, как
и запись, особенно если чтение выполняется в переменные того
же типа, что и переменные, откуда выполнялась запись. Метод
JSONMarshaler.UnmarshalInvoices() принимает значение с поддержкой интерфейса io.Reader , которое может быть значением типа *os.
File, возвращаемым функцией os.Open(), или *gzip.Reader, возвращаемым функцией gzip.NewReader(), или значением любого другого
типа, реализующего интерфейс io.Reader.

{% highlight go %}
func (JSONMarshaler) UnmarshalInvoices(reader io.Reader) ([]*Invoice,
    error) {
    decoder := json.NewDecoder(reader)
    var kind string
    if err := decoder.Decode(&kind); err != nil {
        return nil, err
    }
    if kind != fileType {
        return nil, errors.New("cannot read non-invoices json file")
    }
    var version int
    if err := decoder.Decode(&version); err != nil {
        return nil, err
    }
    if version > fileVersion {
        return nil, fmt.Errorf("version %d is too new to read", version)
    }
    var invoices []*Invoice
    err := decoder.Decode(&invoices)
    return invoices, err
}
{% endhighlight %}

Программе требуется прочитать три элемента данных: тип файла,
версию файла и собственно накладные. Метод json.Decoder.Decode()
принимает указатель на значение, заполненное данными в формате
JSON для обратного преобразования, и возвращает признак ошибки
или nil. Чтобы убедиться, что файл действительно содержит информацию о накладных и его версия поддерживается программой, здесь
используются две переменные (kind и version). Далее выполняется
чтение накладных, в процессе которого метод json.Decoder.Decode()
будет увеличивать размер среза invoices по мере его заполнения и
сохранять в нем указатели на значения типа Invoice (и Item), создаваемые на лету по мере необходимости. В конце метод возвращает
срез invoices и nil или nil и признак ошибки.

Если полагаться исключительно на функциональность пакета
json и для преобразования полей Raised и Due использовать формат
по умолчанию, данного метода было бы вполне достаточно. Однако
из-за того, что в программе выбран особый подход к преобразованию полей Raised и Due типа time.Time (сохраняется только дата),
необходимо реализовать метод обратного преобразования значения
даты в нестандартном формате.

{% highlight go %}
func (invoice *Invoice) UnmarshalJSON(data []byte) (err error) {
    var jsonInvoice JSONInvoice
    if err = json.Unmarshal(data, &jsonInvoice); err != nil {
        return err
    }
    var raised, due time.Time
    if raised, err = time.Parse(dateFormat, jsonInvoice.Raised);
        err != nil {
        return err
    }
    if due, err = time.Parse(dateFormat, jsonInvoice.Due); err != nil {
        return err
    }
    *invoice = Invoice{
        jsonInvoice.Id,
        jsonInvoice.CustomerId,
        raised,
        due,
        jsonInvoice.Paid,
        jsonInvoice.Note,
        jsonInvoice.Items,
    }
    return nil
}
{% endhighlight %}

Этот метод использует ту же структуру JSONInvoice и заполняет ее
данными о накладной с помощью той же стандартной функции json.
Unmarshal() . Затем создается значение типа Invoice, куда копируются данные с датами, преобразованными в значения типа time.Time.
Естественно, метод json.Decoder.Decode() также автоматически
проверяет поддержку интерфейса json.Unmarshaler декодируемым
значением и при ее наличии использует метод UnmarshalJSON(), определяемый значением.

В случае добавления в данные с накладными новых экспортируемых полей этот метод будет их обрабатывать точно так же, при
условии что метод Invoice.UnmarshalJSON() будет учитывать версию
файла. Кроме того, если нулевые значения для новых полей будут
недопустимы, тогда после чтения файлов в первоначальном формате
необходимо предусмотреть дополнительную постобработку данных,
чтобы присвоить новым полям допустимые значения по умолчанию.
(Одно из упражнений в конце главы как раз будет связано с добавлением новых полей и реализацией подобного рода постобработки.)

Формат JSON очень прост в обработке, особенно если создать
подходящие структуры с экспортируемыми полями, однако поддержка двух или более версий форматов файлов может оказаться непростым делом. Кроме того, функции json.Encoder.Encode()
и json.Decoder.Decode() (а также функции json.Marshal() и json.
Unmarshal() ) не являются симметричными друг другу. Это означает,
например, что данные можно преобразовать в формат JSON так, что
невозможно будет выполнить обратное преобразование и точно восстановить оригинальные данные. Поэтому всегда необходимо проверять их корректную работу на конкретных данных.

Между прочим, существует JSON-подобный формат, который
называется BSON (Binary JSON – двоичный JSON), более компактный, чем JSON, и более быстрый. Пакет поддержки формата
BSON (gobson) для языка Go доступен на веб-странице godashboard.
appspot.com/project. (Установка и использование сторонних пакетов
рассматриваются в главе 9.)