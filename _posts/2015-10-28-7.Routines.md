---
layout: post
title:  "7. Параллельное программирование. 7.1. Ключевые понятия"
date:   2015-10-28 21:27:00
categories: go
---

Параллельное программирование позволяет разработчикам реали-
зовывать многопоточные алгоритмы и писать программы, исполь-
зующие преимущества многоядерных процессоров и многопроцес-
сорных систем. Недостаток заключается в том, что многопоточные
программы намного сложнее в создании, сопровождении и отладке
при использовании основных языков программирования (таких как
C, C++ и Java). Кроме того, обработку данных не всегда можно рас-
пределить между несколькими потоками выполнения. И в любом
случае желаемый прирост производительности не всегда достижим
из-за накладных расходов, затрачиваемых на организацию самих по-
токов выполнения, или просто потому, что в многопоточных про-
граммах намного проще допустить ошибку.

Одно из решений состоит в том, чтобы вообще отказаться от
многопоточной модели выполнения. Например, все тяготы можно
переложить на операционную систему, используя ее возможность
параллельного выполнения нескольких процессов. Однако при та-
ком подходе придется решать проблемы, связанные с организацией
взаимодействий между процессами, а кроме того, накладные расхо-
ды на организацию процессов обычно намного выше, чем на органи-
зацию потоков выполнения, действующих в общей области памяти.

Язык Go предлагает трехстороннее решение. Во-первых, он
предоставляет высокоуровневую поддержку параллельного про-
граммирования, что существенно снижает вероятность появления
ошибок. Во-вторых, параллельная обработка производится в go-
подпрограммах, которые намного легче потоков выполнения. И
в-третьих, механизм автоматической сборки мусора освобождает
программистов от управления памятью, иногда дьявольски слож-
ного в параллельных программах.

Встроенный в Go высокоуровневый API для создания параллель-
ных программ основан на модели CSP (Communicating Sequential
Processes – взаимодействующие последовательные процессы) . Это
означает, что явных блокировок и всех хлопот, связанных со своев-
ременным их приобретением и освобождением, можно избежать, а
синхронизацию обеспечить приемом и передачей данных через ка-
налы. Это значительно упрощает создание параллельных программ.
Кроме того, тогда как десятки потоков выполнения могут создать
нагрузку, непомерную для обычного настольного компьютера, тот
же самый компьютер успешно справляется с выполнением сотен,
тысяч и даже десятков тысяч go-подпрограмм. Подход, используе-
мый в языке Go, позволяет программистам рассуждать в терминах
предметной области, а не особенностей использования блокировок
и других низкоуровневых механизмов.

Многие языки программирования имеют поддержку низкоуров-
невых параллельных операций (атомарное сложение, сравнение и
присваивание), а также некоторых низкоуровневых механизмов, та-
ких как мьютексы. Но ни в одном из основных языков нет такой вы-
сокоуровневой встроенной поддержки параллельного выполнения,
как в языке Go (исключение составляют разве что дополнительные
библиотеки, которые не являются неотъемлемой частью языка).

В дополнение к высокоуровневой поддержке параллельного вы-
полнения, которая является темой этой главы, в языке Go имеется
также поддержка тех же низкоуровневых механизмов, что и в других
языках. На самом низком уровне пакет sync/atomic из стандартной
библиотеки предоставляет функции для выполнения операций ато-
марного сложения, сравнения и присваивания. Эти дополнительные
функции созданы для поддержки реализации поточно-ориентиро-
ванных алгоритмов синхронизации и структур данных – они не
предназначены для использования прикладными программистами.
Пакет sync реализует самые обычные низкоуровневые примитивы
многопоточной модели выполнения: переменные состояния и мью-
тексы. В большинстве других языков программирования они счи-
таются высокоуровневыми механизмами, поэтому прикладные про-
граммисты часто вынуждены использовать их.

При разработке параллельных программ на языке Go приклад-
ные программисты предпочитают использовать высокоуровневые
механизмы – каналы и go-подпрограммы. Кроме того, существует
тип sync.Once, позволяющий обеспечить однократный вызов функ-
ции независимо от количества ее вызовов в программе, и тип sync.
WaitGroup, предоставляющий высокоуровневый механизм синхрони-
зации, как будет показано ниже.

Базовый синтаксис и порядок использования каналов и go-
подпрограмм уже были представлены в главе 5 (§5.4). Эти сведения
не будут повторяться в данной главе, но предполагается их знание,
поэтому кому-то может оказаться полезным вернуться и повторно
прочитать указанный раздел или хотя бы вскользь пробежаться по
нему взглядом, прежде чем продолжить чтение.

Эта глава начинается с обзора некоторых ключевых понятий
параллельного программирования на языке Go. Затем в ней будет
представлено пять законченных действующих программ, иллюстри-
рующих особенности параллельного программирования на языке
Go, а также некоторые стандартные приемы. Первый пример пока-
жет, как организовать конвейерную обработку, где каждый сегмент
конвейера выполняется в отдельной go-подпрограмме для обеспе-
чения максимальной пропускной способности. Второй пример по-
кажет, как распределить работу между фиксированным числом go-
подпрограмм, которые выводят свои результаты независимо друг от
друга. Третий пример покажет, как создать поточно-ориентированую
структуру данных без использования блокировок или других низ-
коуровневых примитивов. Четвертый пример покажет три разных
варианта, как с использованием фиксированного количества go-
подпрограмм организовать решение независимых подзадач с объ-
единением результатов. Пятый пример покажет, как создать опре-
деленное число go-подпрограмм в зависимости от типа обработки и
как объединить результаты работы этих go-подпрограмм в единый
набор результатов.

## 7.1. Ключевые понятия

Параллельное программирование обычно используется, чтобы
распределить обработку данных между одной или несколькими
go-подпрограммами (выполняющимися параллельно основной go-
подпрограмме) и вывести результаты по мере их готовности или
собрать их воедино для вывода по окончании обработки.

Даже при использовании высокоуровневых механизмов парал-
лельного выполнения, имеющихся в языке Go, есть риск попасть
в ловушки. Одна из таких ловушек – практически немедленное
завершение программы до того, как она успеет вывести результа-
ты. Программы на языке Go завершаются автоматически, с завер-
шением главной go-подпрограммы, даже если в это время другие
go-подпрограммы продолжают выполняться. Поэтому необходимо
задержать завершение главной go-подпрограммы, пока вся работа
не будет выполнена.

Еще одна ловушка, которой следует опасаться, – взаимоблоки-
ровка . Одна из разновидностей этой проблемы является практиче-
ски полной противоположностью первой ловушки: главная и все
остальные go-подпрограммы продолжают выполняться даже после
завершения обработки данных. Обычно это происходит из-за ошиб-
ки передачи сообщения о завершении обработки. Другой разновид-
ностью взаимоблокировки является ситуация, когда две разные go-
подпрограммы (или потока выполнения) используют блокировки
для защиты доступа к ресурсу и пытаются одновременно приобре-
сти одни и те же блокировки, как показано на рис. 7.1. Проблемы
подобного рода могут возникать только при использовании блоки-
ровок. Это широко распространенная проблема в других языках
программирования, но крайне редкая в Go, потому что приложения
на языке Go вместо блокировок могут использовать каналы.

Наиболее типичный способ избежать преждевременного заверше-
ния или бессмысленного продолжения работы заключается в том,
чтобы заставить главную go-подпрограмму ожидать получения со-
общения о завершении работы из канала, созданного исключительно
для этой цели (как будет показано чуть ниже, а также в §7.2.2 и
§7.2.4). (Для этого можно также использовать специально подго-
товленное значение, передаваемое как последний «результат», но по
сравнению с другими это решение выглядит несколько неуклюже.)

Другой способ избежать ловушек состоит в том, чтобы ждать, пока
все go-подпрограммы сообщат о завершении обработки с помощью
значения типа sync.WaitGroup. Однако использование значения этого
типа само может стать причиной взаимоблокировки, особенно если
вызвать sync.WaitGroup.Wait() в главной go-подпрограмме, когда все
go-подпрограммы, выполняющие обработку, окажутся заблокированы
(например, в ожидании приема данных из канала). Порядок исполь-
зования значения типа sync.WaitGroup будет описан ниже (§7.2.5).

!["Рис. 7.1. Взаимоблокировка: два или более блокирующих потока пытаются приобрести блокировку, занятую другим потоком"](/images/ris-7-1.jpg "Рис. 7.1. Взаимоблокировка: два или более блокирующих потока пытаются приобрести блокировку, занятую другим потоком")

Программы на языке Go могут попасть в состояние взаимобло-
кировки, даже если в них использовать только каналы и полностью
исключить применение блокировок. Например, представьте, что
имеется множество go-подпрограмм, которые могут запрашивать
друг у друга выполнение некоторых функций (например, отправляя
запросы друг другу). Если такая функция пошлет сообщение go-
подпрограмме, в рамках которой она выполняется, например чтобы
передать некоторые данные, получится взаимоблокировка. Эта ситу-
ация изображена на рис. 7.2. (Позднее будут представлены примеры,
где возможны взаимоблокировки такого рода.)

Каналы – это механизм взаимодействий между параллельно выпол-
няющимися go-подпрограммами без применения блокировок. (За ку-
лисами блокировки могут использоваться, но это тонкости реализации,
которые нас не касаются.) При использовании каналов синхронизация
отправляющего и принимающего концов канала (и соответствующих
им go-подпрограмм) выполняется в момент взаимодействия.

По умолчанию каналы являются двунаправленными, то есть они
позволяют посылать и принимать значения. Однако очень часто ка-
налы, которые являются полями структур или передаются в виде
параметров, являются однонаправленными, то есть они позволяют
либо только посылать, либо только принимать значения. В таких
случаях семантику использования канала можно выразить (и вы-
нудить компилятор автоматически проверять ее), указывая направ-
ление работы канала. Например, тип chan<- Тип описывает канал,
позволяющий только посылать значения, а тип <-chan Тип – только
принимать. В предыдущих главах этот синтаксис не использовался,
потому что в этом не было необходимости – во всех случаях можно
было использовать тип chan Тип, – и там рассказывалось совсем о
другом. Но с данного момента везде, где это возможно, будут ис-
пользоваться однонаправленные каналы, потому что они удобнее в
использовании и дают преимущество дополнительной проверки на
этапе компиляции.

!["Рис. 7.2. Взаимоблокировка: go-подпрограмма пытается обслужить запрос запросом к себе самой"](/images/ris-7-2.jpg "Рис. 7.2. Взаимоблокировка: go-подпрограмма пытается обслужить запрос запросом к себе самой")

Посылка через каналы значений таких типов, как bool , int и
float64 , совершенно безопасна, потому что посылаются их копии, то
есть полностью отсутствует риск случайного одновременного обра-
щения к одному и тому же значению из нескольких go-подпрограмм.
Аналогично посылка строк также безопасна, потому что они явля-
ются неизменяемыми значениями.

Посылка указателей или ссылок (например, срезов или отобра-
жений) через каналы по своей природе небезопасна, потому что
значения, на которые ссылаются указатели или ссылки, могут из-
меняться посылающей и принимающей go-подпрограммами, что
может приводить к непредсказуемым результатам. Поэтому, когда
дело доходит до указателей и ссылок, необходимо гарантировать,
что обращаться к ним будет только одна go-подпрограмма, то есть
обеспечить поочередный доступ . Исключение составляют случаи,
когда в документации явно говорится, что посылать указатель без-
опасно, например одно и то же значение типа *regexp.Regexp мо-
жет безопасно использоваться несколькими go-подпрограммами,
потому что ни один из его методов не изменяет состояния зна-
чения.

Один из способов обеспечить последовательный доступ заключа-
ется в использовании мьютексов. Другой – в соблюдении правила,
согласно которому отправитель не должен обращаться к указателю
или ссылке после отправки. Это позволит получателю безопасно ис-
пользовать значение, полученное по указателю или по ссылке, а так-
же посылать указатель или ссылку дальше, при соблюдении того же
правила. (Пример использования этого правила будет представлен
ниже, в §7.2.4.3.) Недостаток решений на основе подобных правил
в том, что они требуют определенной дисциплины программирова-
ния. Третий способ обеспечить безопасную работу с указателями и
ссылками заключается в реализации экспортируемых методов, кото-
рые не изменяют значения, и неэкспортируемых методов, произво-
дящих изменения. Такие указатели или ссылки могут передаваться
и безопасно использоваться параллельными go-подпрограммами по-
средством экспортируемых методов и позволить использовать не-
экспортируемые методы только одной go-подпрограмме (например,
внутри пакета, где объявляется тип указателя или ссылки; подроб-
нее о пакетах рассказывается в главе 9).

Имеется также возможность посылать через каналы интерфей-
сы , то есть значения, реализующие определенный интерфейс. Зна-
чения, реализующие интерфейсы, обеспечивающие доступ только
для чтения, могут безопасно использоваться любым количеством
go-подпрограмм (если документация явно не оговаривает иное), но
значения, реализующие интерфейсы, которые включают методы для
изменения значения, должны обрабатываться подобно указателям –
поочередно.

Например, при создании нового изображения вызовом функ-
ции image.NewRGBA() программа получит значение типа *image.
RGBA. Этот тип реализует два интерфейса: image.Image (содержа-
щий только методы чтения) и draw.Image (содержащий все методы
интерфейса image.Image плюс метод Set()). Поэтому одно и то же
значение типа *image.RGBA безопасно передавать любому количеству
go-подпрограмм, если оно посылается как значение, реализующее
интерфейс image.Image . (К сожалению, безопасность в этом случае
может быть нарушена принимающей стороной, использующей опе-
рацию приведения типа , например к интерфейсу draw.Image, поэто-
му желательно предусмотреть правила, препятствующие появлению
таких ситуаций.) А если необходимо послать одно и то же значение
типа *image.RGBA нескольким go-подпрограммам, которые могут из-
менить его, его следует посылать как значение типа *image.RGBA или
как значение, реализующее интерфейс draw.Image , и в любом случае
необходимо обеспечить последовательный доступ к значению.

Один из простейших способов организации параллельной обра-
ботки заключается в использовании одной go-подпрограммы для
подготовки заданий и второй – для их выполнения. При таком
подходе главной go-подпрограмме остается только создать каналы
и обеспечить общую организацию процесса обработки. Например,
ниже показано, как в главной go-подпрограмме создать канал для
передачи заданий и канал для передачи сообщения о завершении
обработки.


{% highlight go %}
jobs := make(chan Job)
done := make(chan bool, len(jobList))
{% endhighlight %}

Здесь создается небуферизованный канал jobs для передачи зна-
чений пользовательского типа Job, а также буферизованный канал
done, размер буфера которого соответствует количеству заданий в
переменной jobList типа []Job (инициализация переменной здесь
не показана).

После создания каналов и списка заданий можно приступать к
обработке.

{% highlight go %}
go func() {
	for _, job := range jobList {
		jobs <- job // Заблокируется, пока принимающая сторона не прочитает задание
	}
	close(jobs)
}()
{% endhighlight %}

В этом фрагменте создается первая go-подпрограмма. Она вы-
полняет итерации по срезу jobList и посылает каждое задание в
канал jobs. Поскольку канал небуферизованный, go-подпрограмма
немедленно блокируется и остается в таком состоянии, пока вторая
go-подпрограмма не прочитает значение из канала jobs. После от-
правки всех заданий канал jobs закрывается, чтобы сообщить при-
нимающей стороне, что заданий больше не будет.

Семантика этого фрагмента далеко не очевидна! Цикл for вы-
полняется до исчерпания списка заданий, после чего канал jobs за-
крывается, но все эти действия выполняются параллельно с другими
go-подпрограммами. Кроме того, инструкция go вернет управление
немедленно, оставив программный код выполняться в отдельной go-
подпрограмме, и, так как в этот момент никто еще не пытается про-
читать задание из канала, go-подпрограмма окажется заблокирован-
ной. То есть сразу после выполнения этой инструкции go в программе
одновременно будут выполняться две go-подпрограммы – главная
go-подпрограмма, которая приступит к выполнению следующей ин-
струкции, и эта, вновь созданная go-подпрограмма, заблокированная
в ожидании, когда другая go-подпрограмма примет задание из кана-
ла. Следовательно, пройдет некоторое время, прежде чем цикл for
завершится и канал закроется.


{% highlight go %}
go func() {
	for job := range jobs { // Заблокируется в ожидании передачи
		fmt.Println(job)
		// Выполнение задания
		done <- true
	}
}()
{% endhighlight %}

Этот фрагмент создает вторую go-подпрограмму. Эта go-
подпрограмма выполняет итерации по каналу jobs, извлекает за-
дания, обрабатывает их (просто выводит) и для каждого задания
посылает значение true в канал done, сообщая о его завершении. (С
таким же успехом можно было бы посылать значение false, потому
что здесь просто подсчитывается количество посылок в канал done,
а фактически посланные значения не учитываются.)

Как и первая инструкция go , эта инструкция возвращает управ-
ление немедленно, а инструкция for блокируется в ожидании по-
сылки. То есть в этой точке в программе будут одновременно вы-
полняться уже три go-подпрограммы – главная go-подпрограмма и
две дополнительные go-подпрограммы, как показано на рис. 7.3.

Так как первая go-подпрограмма уже готова отправить задание, оно
будет немедленно получено и обработано второй go-подпрограммой.
Тем временем первая go-подпрограмма снова заблокируется, на
этот раз в операции посылки второго задания. Как только вторая
go-подпрограмма закончит обработку, она пошлет значение в канал
done – это буферизованный канал, и поэтому операция посылки
блокироваться не будет. Затем управление вернется в начало цикла
for во второй go-подпрограмме, и следующее задание будет послано
первой и принято второй go-подпрограммой и т. д., пока все задания
не будут выполнены.

{% highlight go %}
for i := 0; i < len(jobList); i++ {
	<-done // Заблокируется в ожидании передачи
}
{% endhighlight %}

Этот заключительный фрагмент начнет выполнение сразу после
создания и запуска двух go-подпрограмм. Данный программный код
выполняется в главной go-подпрограмме, и его назначение – гаран-
тировать, что главная go-подпрограмма не завершится, пока не бу-
дут выполнены все задания.
Цикл for выполнит итерации по количеству заданий, но в каждой
итерации будет выполнен прием значения из канала done (которое
тут же отбрасывается), чтобы синхронизировать каждую итерацию
с завершением выполнения очередного задания. Если прием из
канала невозможен (например, потому что задание еще не выпол-
нено), операция приема будет заблокирована. Как только выполне-
ние заданий завершится, число посылок и приемов из канала done
станет равно указанному числу итераций и цикл for завершится.
Теперь главная go-подпрограмма сможет завершиться, завершая тем
самым программу, и мы можем быть уверены, что все задания были
обработаны.

!["Рис. 7.3. Параллельная независимая подготовка и выполнение заданий"](/images/ris-7-3.jpg "Рис. 7.3. Параллельная независимая подготовка и выполнение заданий")

При работе с каналами обычно следует придерживаться двух
правил. Во-первых, канал должен закрываться, только если позднее
его состояние будет проверяться программой (например, с помощью
цикла for ... range, инструкцией select или операцией контроли-
руемого приема с помощью оператора <-). Во-вторых, канал должен
закрываться посылающей go-подпрограммой, а не принимающей. В
общем случае нет смысла закрывать каналы, если потом нигде не
будет проверяться их состояние – каналы представляют собой очень
легковесный механизм, и они не будут потреблять дополнительных
ресурсов, как, например, открытые файлы.

В этом примере по каналу jobs выполняются итерации с помо-
щью цикла for ... range, поэтому канал закрывается, и делается
это внутри посылающей go-подпрограммы в соответствии с описан-
ными выше правилами. Канал done, напротив, можно не закрывать,
потому что ниже в программе нет инструкций, выполнение которых
зависело бы от состояния канала.

Этот пример иллюстрирует типичный шаблон параллельного
программирования на языке Go, хотя в данном конкретном случае
использование параллельно выполняющихся go-подпрограмм не не-
сет никаких преимуществ. Некоторые примеры, представленные в
следующем разделе, используют похожий шаблон и с выгодой при-
меняют параллельно выполняющиеся go-подпрограммы.