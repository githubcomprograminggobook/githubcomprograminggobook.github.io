---
layout: post
title:  "7.2.5. Пример: поиск дубликатов"
date:   2015-11-20 14:00:00
categories: go
---

В этом заключительном примере будет представлена программа, пытающаяся отыскать дубликаты файлов не на основе их имен, а на
основе размеров и контрольных сумм SHA-1 1 .

Рассматриваемая ниже программа называется findduplicates (в
файле findduplicates/findduplicates.go). Для итераций по файлам и
каталогам в указанном пути, включая подкаталоги, подподкаталоги
и т. д., она использует функцию filepath.Walk() из стандартной библиотеки. Программа применяет переменное число go-подпрограмм в
зависимости от выполняемой работы. Для каждого «большого» файла
создается дополнительная go-подпрограмма, вычисляющая контрольную сумму SHA-1, тогда как для «маленьких» файлов вычисление
контрольной суммы SHA-1 производится в текущей go-подпрограмме.
Это означает, что заранее неизвестно, как много go-подпрограмм будет выполняться при каждом конкретном запуске программы, хотя
можно и должно устанавливать верхний предел их количества.
Один из способов обслуживания переменного числа go-подпрограмм заключается в использовании канала для получения
извещений о завершении работы, как это делалось в предыдущих
примерах, и ведении учета количества созданных go-подпрограмм.
Однако проще всего задействовать значение типа sync.WaitGroup , позволяющее добиться того же эффекта, но при этом бремя учета перекладывается на плечи окружения времени выполнения языка Go.

{% highlight go %}
func main() {
    runtime.GOMAXPROCS(runtime.NumCPU()) // Use all the machine's cores
    if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {
        fmt.Printf("usage: %s <path>\n", filepath.Base(os.Args[0]))
        os.Exit(1)
    }

    infoChan := make(chan fileInfo, maxGoroutines*2)
    go findDuplicates(infoChan, os.Args[1])
    pathData := mergeResults(infoChan)
    outputResults(pathData)
}
{% endhighlight %}

Функция main() извлекает путь к каталогу, откуда следует начинать работу, и руководит всем процессом. Она начинается с создания
канала fileInfo для передачи значений (будет показан чуть ниже).
Канал создается буферизованным, потому что, как показали эксперименты, это ведет к увеличению производительности.

Далее функция запускает функцию findDuplicates() в go-подпрограмме, после чего вызывает функцию mergeResults(), которая читает данные из канала infoChan, пока он не будет закрыт.
После объединения полученных данных она возвращает их, и результаты выводятся в консоль.

!["Рис. 7.8. Множество независимых заданий с синхронизацией результатов"](/images/ris-7-8.jpg "Рис. 7.8. Множество независимых заданий с синхронизацией результатов")

Потоки взаимодействий в программе и go-подпрограммы изображены на рис. 7.8. Результаты передаются через канал infoChan в виде
значений типа fileInfo. Они посылаются функцией «обхода» (типа
filepath.WalkFunc), которая передается функции filepath.Walk(). Сама
функция filepath.Walk() вызывается в функции findDuplicates(). Результаты принимаются функцией mergeResults(). Go-подпрограммы,
изображенные на рис. 7.8, создаются функцией findDuplicates() и
функцией обхода. Кроме того, функция filepath.Walk() из стандартной библиотеки может создавать собственные go-подпрограммы (например, по одной для обработки каждого каталога), хотя принцип ее
действия зависит от особенностей конкретной реализации.

{% highlight go %}
type fileInfo struct {
    sha1 []byte
    size int64
    path string
}
{% endhighlight %}

Этот тип используется для хранения информации о каждом файле. Если два файла имеют одинаковые размеры и контрольные суммы SHA-1, они считаются дубликатами независимо от путей к ним
или их имен.

{% highlight go %}
func findDuplicates(infoChan chan fileInfo, dirname string) {
    waiter := &sync.WaitGroup{}
    filepath.Walk(dirname, makeWalkFunc(infoChan, waiter))
    waiter.Wait() // Blocks until all the work is done
    close(infoChan)
}
{% endhighlight %}

Данная функция вызывает функцию filepath.Walk() для обхода
дерева каталогов (начиная с dirname), которая для каждого файла
и каталога вызывает функцию filepath.WalkFunc, переданную ей во
втором аргументе.

Функция обхода может создавать произвольное количество go-подпрограмм, поэтому необходим инструмент, гарантирующий, что
функция findDuplicates() не вернет управления, пока все они не
закончат работу. В данном случае роль такого инструмента играет
значение типа sync.WaitGroup. Каждый раз, когда создается новая go-подпрограмма, вызывается метод sync.WaitGroup.Add() , а каждый раз,
когда очередная go-подпрограмма завершает работу, вызывается метод sync.WaitGroup.Done() . После запуска всех go-подпрограмм, для
ожидания их завершения, вызывается метод sync.WaitGroup.Wait(),
который блокируется, пока количество запущенных go-подпрограмм
не сравняется с количеством завершившихся go-подпрограмм.

Когда рабочие go-подпрограммы закончат работу, не останется
ни одной, которая посылала бы значения fileInfo в канал infoChan,
поэтому канал закрывается. Естественно, функция mergeResults()
сохраняет возможность принимать значения из канала, пока канал
не опустеет.

{% highlight go %}
const maxSizeOfSmallFile = 1024 * 32

func makeWalkFunc(infoChan chan fileInfo,
    waiter *sync.WaitGroup) func(string, os.FileInfo, error) error {
    return func(path string, info os.FileInfo, err error) error {
        if err == nil && info.Size() > 0 &&
            (info.Mode()&os.ModeType == 0) {
            if info.Size() < maxSizeOfSmallFile ||
                runtime.NumGoroutine() > maxGoroutines {
                processFile(path, info, infoChan, nil)
            } else {
                waiter.Add(1)
                go processFile(path, info, infoChan,
                    func() { waiter.Done() })
            }
        }
        return nil // We ignore all errors
    }
}
{% endhighlight %}

Эта функция создает и возвращает анонимную функцию типа filepath.WalkFunc (то есть функцию с сигнатурой func(string,
os.FileInfo, error) error) . Эта функция будет вызываться для
каждого файла и каталога, которые встретятся функции filepath.
Walk(). Аргумент path – это имя файла или каталога, info – результаты системного вызова stat для этого файла или каталога и err – либо nil, либо значение с информацией об ошибке, встретившейся при
попытке проанализировать имя path. Пропускать каталоги можно,
возвращая значение ошибки filepath.SkipDir , а остановить обход
дерева каталогов – вернув любое другое, непустое значение ошибки.

В программе решено было обрабатывать только обычные файлы
ненулевого размера. (Разумеется, все файлы, имеющие размер 0
байт, являются идентичными, но программа игнорирует такие файлы.) Значение os.ModeType – это битовая маска, имеющая биты, обозначающие каталоги, символические ссылки, именованные каналы,
сокеты и устройства, то есть если не установлен ни один из этих
битов, значит, программа имеет дело с обычным файлом.

Если файл «маленький» (в данном случае до 32 Кбайт), контрольная сумма SHA-1 вычисляется немедленно, вызовом функции
processFile(). Но для всех остальных файлов создается новая go-подпрограмма, в которой функция processFile() выполняется асинхронно. Это означает, что маленькие файлы будут блокировать работу функции (пока не будет вычислена контрольная сумма SHA-1), а
большие – нет, потому что для них вычисление контрольных сумм
будет выполняться в отдельной go-подпрограмме. В любом случае,
по завершении вычислений полученное значение fileInfo посылается в канал infoChan.

Создавая новую go-подпрограмму, необходимо вызвать метод
sync.WaitGroup.Add() , а когда она завершает обработку, следует обязательно выполнить соответствующий вызов метода sync.WaitGroup.
Done() . Для этой цели используется поддержка замыканий в языке
Go (§5.6.3). Если функция processFile() вызывается в новой go-подпрограмме, ей в последнем аргументе передается анонимная
функция, которая вызывает метод sync.WaitGroup.Done(). Предполагается, что функция processFile() выполнит отложенный вызов
этой анонимной функции, чтобы обеспечить вызов метода Done() по
завершении работы go-подпрограммы. Если функция processFile()
вызывается в текущей go-подпрограмме, вместо анонимной функции ей в последнем аргументе передается значение nil.

Почему бы просто не обрабатывать все файлы в новых go-подпрограммах? В языке Go с этим нет никаких проблем, поскольку
он позволяет создавать сотни и тысячи go-подпрограмм. К сожалению, большинство операционных систем устанавливают верхний
предел на количество файлов, которые могут быть открыты одновременно. В Windows предел по умолчанию составляет 512 файлов,
хотя его можно повысить до 2048. В системах Mac OS X предел по
умолчанию составляет 256 файлов, в Linux – 1024, однако в Unixподобных системах, как эти, обычно имеется возможность повысить
предел до десятков и сотен тысяч. Очевидно, если создавать по одной go-подпрограмме на каждый файл, на некоторых платформах
программа легко может превысить установленный предел.

Чтобы избежать проблемы «слишком большого числа открытых файлов», в программе используется комбинация из двух тактик. Во-первых,
маленькие файлы обрабатываются в одной go-подпрограмме (или,
возможно, в нескольких go-подпрограммах, если функция filepath.
Walk() будет распределять работу по нескольким go-подпрограммам и
вызывать функцию обхода из них). Это гарантирует, что при попадании в каталог с тысячами маленьких файлов программа не сможет
открыть их слишком много, потому что только одна или несколько
go-подпрограмм смогут обрабатывать их одновременно.

Большие файлы можно позволить обрабатывать в отдельных
go-подпрограммах, потому что сам факт, что они большие, означает низкую вероятность, что одновременно будет открыто слишком
много файлов. Но если программа встретит слишком большое количество больших файлов, то есть если она создаст слишком много go-подпрограмм, в действие вступит вторая тактика. (Функция runtime.
NumGoroutine() позволяет узнать количество go-подпрограмм, выполняющихся в текущий момент времени.)

Если окажется, что было запущено слишком много go-подпрограмм,
создание новых go-подпрограмм для больших файлов прекратится,
и все файлы, независимо от размера, будут обрабатываться в текущей go-подпрограмме. Это вынудит программу использовать ту же
самую go-подпрограмму (или несколько go-подпрограмм) для обработки каждого последующего файла, остановит рост количества go-подпрограмм и как следствие ограничит количество файлов, открытых одновременно. По мере завершения go-подпрограмм, обрабатывающих большие файлы, их количество будет уменьшаться. Поэтому
в некоторый момент количество go-подпрограмм окажется меньше
установленного предела, и тогда вновь для обработки больших файлов начнут создаваться отдельные go-подпрограммы.

{% highlight go %}
func processFile(filename string, info os.FileInfo,
    infoChan chan fileInfo, done func()) {
    if done != nil {
        defer done()
    }
    file, err := os.Open(filename)
    if err != nil {
        log.Println("error:", err)
        return
    }
    defer file.Close()
    hash := sha1.New()
    if size, err := io.Copy(hash, file);
        size != info.Size() || err != nil {
        if err != nil {
            log.Println("error:", err)
        } else {
            log.Println("error: failed to read the whole file:", filename)
        }
        return
    }
    infoChan <- fileInfo{hash.Sum(nil), info.Size(), filename}
}
{% endhighlight %}

Эта функция вызывается из текущей go-подпрограммы или из
вновь созданной дополнительной go-подпрограммы для вычисления
контрольной суммы SHA-1 указанного файла и отправки информации о файле в канал infoChan.

Если аргумент done имеет значение, отличное от nil, следовательно, данная функция была вызвана в новой go-подпрограмме,
поэтому она производит отложенный вызов функции done() (которая просто вызывает метод sync.WaitGroup.Done() ). Это гарантирует,
что для каждого вызова метода sync.WaitGroup.Add() будет выполнен парный ему вызов метода Done(), так как это очень важно для
корректной работы функции sync.WaitGroup.Wait() . Если аргумент
имеет значение nil, он просто игнорируется.

Затем указанный файл открывается для чтения, а его закрытие откладывается до завершения функции, как обычно. В пакете crypto/sha1 из стандартной библиотеки имеется функция sha1.
New() , возвращающая значение, реализующее интерфейс hash.Hash.
Этот интерфейс определяет метод Sum(), возвращающий значение
контрольной суммы (20-байтное значение хеша SHA-1), которое реализует интерфейс io.Writer . (Здесь методу Sum() передается значение nil, чтобы создать новый срез типа []byte, однако при желании
ему можно было бы передавать имеющийся срез типа []byte, в конец
которого была бы добавлена контрольная сумма.)

Здесь можно было бы прочитать содержимое файла целиком и
затем вызвать метод sha1.Write() для записи файла в хеш, но в
программе решено было использовать более эффективный подход
и применить функцию io.Copy() . Эта функция принимает значение,
реализующее запись (в данном случае – хеш), и значение, реализующее чтение (здесь – открытый файл), и копирует из последнего
в первое. Когда копирование завершится, io.Copy() вернет количество скопированных байт и либо значение nil, либо значение типа
error в случае ошибки. Поскольку хеш SHA-1 может работать сразу
с целыми фрагментами данных, максимальный объем памяти, используемой функцией io.Copy() , будет равен размеру буфера, используемого хешем SHA-1, плюс некоторый фиксированный объем.
Если читать файлы в память целиком, расходовался бы тот же объем
памяти, плюс память для хранения всего файла. Поэтому, особенно
для больших файлов, функция io.Copy() позволяет получить ощутимую экономию.

Когда вычисления завершатся, в канал infoChan посылается
значение типа fileInfo с полученной контрольной суммой SHA-,
размером файла (доступен в значении типа os.FileInfo , передаваемом функции processFile() из функции обхода) и именем файла
(включая полный путь).

{% highlight go %}
type pathsInfo struct {
    size  int64
    paths []string
}
{% endhighlight %}

Значения этого типа используются для хранения информации о
каждом повторяющемся файле, то есть его размер, а также все пути
и имена файлов. Значения данного типа используются функциями
mergeResults() и outputResults().

{% highlight go %}
func mergeResults(infoChan <-chan fileInfo) map[string]*pathsInfo {
    pathData := make(map[string]*pathsInfo)
    format := fmt.Sprintf("%%016X:%%%dX", sha1.Size*2) // == "%016X:%40X"
    for info := range infoChan {
        key := fmt.Sprintf(format, info.size, info.sha1)
        value, found := pathData[key]
        if !found {
            value = &pathsInfo{size: info.size}
            pathData[key] = value
        }
        value.paths = append(value.paths, info.path)
    }
    return pathData
}
{% endhighlight %}

Эта функция начинается с создания отображения для сохранения
информации о дубликатах файлов. Ключами в нем являются строки,
составленные из размера файла, двоеточия и контрольной суммы
SHA-1, а значениями – указатели *pathsInfo.

Строка format используется для создания ключей, состоящих из
16 шестнадцатеричных цифр с ведущими нулями, представляющих
размер файла, и некоторого количества шестнадцатеричных цифр,
достаточного для представления контрольной суммы SHA-1 файла.
Ведущие нули в части, представляющей размер файла, используются с целью упростить сортировку по ключам. Константа sha1.Size
хранит количество байт в контрольной сумме SHA-1 (то есть 20).
Так как один байт представлен двумя шестнадцатеричными цифрами, число, определяющее в строке формата ширину поля для вывода
контрольной суммы SHA-1, должно быть вдвое больше количества
байт. (Между прочим, строку формата можно было бы создать немного иначе: format = "%016X:%" + fmt.Sprintf("%dX", sha1.Size*2).)

Посылка данных в канал infoChan выполняется множеством go-подпрограмм, но прием данных канала производит только одна
функция (в главной go-подпрограмме). Цикл for принимает значения типа fileInfo или блокируется в их ожидании. Когда из канала
infoChan будут приняты все значения и канал закроется, цикл завершится. Для каждого принятого значения типа fileInfo создается строка с ключом в отображении. Если элемент с таким ключом
отсутствует в отображении, создается соответствующее значение с
указанным размером файла и пустым срезом, которое добавляется
в отображение с новым ключом. Затем в конец поля paths нового
или существовавшего ранее элемента отображения добавляется путь
к файлу из значения типа fileInfo.

В конце это приведет к тому, что для повторяющихся файлов срезы будут хранить более одного пути, а для неповторяющихся – только один. После обработки всех значений типа fileInfo и заполнения
отображения функция вернет отображение, готовое к дальнейшей
обработке.

{% highlight go %}
func outputResults(pathData map[string]*pathsInfo) {
    keys := make([]string, 0, len(pathData))
    for key := range pathData {
        keys = append(keys, key)
    }
    sort.Strings(keys)
    for _, key := range keys {
        value := pathData[key]
        if len(value.paths) > 1 {
            fmt.Printf("%d duplicate files (%s bytes):\n",
                len(value.paths), commas(value.size))
            sort.Strings(value.paths)
            for _, name := range value.paths {
                fmt.Printf("\t%s\n", name)
            }
        }
    }
}
{% endhighlight %}

Ключи отображения pathData являются строками, начинающимися с 16-значных шестнадцатеричных значений размеров файлов
с ведущими нулями. (16 цифр было выбрано потому, что этого их
количества достаточно для представления любых чисел типа int64 .)
Это означает, что, выполняя сортировку по ключам, можно отсортировать элементы отображения по размеру файлов. Поэтому функция начинается с создания среза keys, после чего в него добавляются ключи из отображения и выполняется сортировка среза. Затем
функция выполняет итерации по отсортированному срезу с ключами и извлекает соответствующие им значения типа pathsInfo. Для
значений, где имеются несколько путей, выводится размер файла
и затем с отступом список путей к повторяющимся файлам в алфавитном порядке, как показано ниже.

{% highlight go %}
$ ./findduplicates $GOROOT
2 duplicate files (67 bytes):
/home/mark/opt/go/test/fixedbugs/bug248.dir/bug0.go
/home/mark/opt/go/test/fixedbugs/bug248.dir/bug1.go
...
4 duplicate files (785 bytes):
/home/mark/opt/go/doc/gopher/gophercolor16x16.png
/home/mark/opt/go/favicon.ico
/home/mark/opt/go/misc/dashboard/godashboard/static/favicon.ico
/home/mark/opt/go/src/pkg/archive/zip/testdata/gophercolor16x16.png
...
2 duplicate files (1,371,249 bytes):
/home/mark/opt/go/bin/ebnflint
/home/mark/opt/go/src/cmd/ebnflint/ebnflint
{% endhighlight %}

Здесь было опущено множество строк, обозначенных многоточиями.

{% highlight go %}
func commas(x int64) string {
    value := fmt.Sprint(x)
    for i := len(value) - 3; i > 0; i -= 3 {
        value = value[:i] + "," + value[i:]
    }
    return value
}
{% endhighlight %}

Большинству пользователей сложно воспринимать на глаз длинные числа (например, 1371249), поэтому здесь использована простая
функция commas() , вставляющая запятые между группами разрядов,
чтобы упростить восприятие значений размеров файлов. Функция
принимает единственное значение типа int64, то есть если имеется значение типа int или integer другого целочисленного типа,
его необходимо преобразовать в значение типа int64, например:
commas(int64(i)) 1 .

На этом завершается наш обзор программы findduplicates и приемов параллельного программирования на языке Go в целом. Поддержка параллельного выполнения в языке Go (<-, chan , go , select )
обладает большой гибкостью и допускает такое количество способов
организации параллельной обработки данных, что здесь не хватило
бы места, чтобы показать их все. Тем не менее примеры и упражнения, следующие ниже, дают достаточный объем знаний и навыков
параллельного программирования на языке Go, чтобы уверенно применять их при создании новых программ параллельной обработки.

Конечно, невозможно сказать определенно, какой из рассмотренных (или других возможных) подходов является лучшим, так как
каждый из них может оказаться лучшим при различных обстоятельствах. Производительность каждого из подходов во многом зависит
от конкретного компьютера, количества go-подпрограмм и от местоположения обрабатываемых данных – в памяти или на внешних
носителях (например, в сети). Надежный способ выбора лучшего
подхода для конкретной программы заключается в том, чтобы провести тестирование на фактических данных с использованием разных подходов и с разным числом go-подпрограмм.
