---
layout: post
title:  "8. Обработка файлов"
date:   2015-11-20 19:00:00
categories: go
---

В предыдущих главах было показано несколько примеров операций
создания, чтения и записи текстовых файлов. В этой главе мы более
подробно рассмотрим имеющиеся в языке Go инструменты для работы с файлами и в особенности способы чтения и записи файлов
стандартных форматов (таких как XML и JSON), а также пользовательских текстовых и двоичных форматов.

К настоящему моменту были охвачены все особенности языка Go
(кроме создания программ с собственными и сторонними пакетами,
о которых рассказывается в следующей главе), поэтому теперь можно свободно использовать любые возможности, предоставляемые
языком Go. Теперь мы можем, пользуясь этой свободой, задействовать замыкания (§5.6.3), чтобы избежать дублирования программного кода, и в некоторых случаях более широко использовать поддержку объектно-ориентированного программирования, создавая методы
вдобавок к функциям.

В этой главе основное внимание будет уделено не каталогам или
файловым системам, а файлам. Что касается каталогов, пример
findduplicates из предыдущей главы (§7.2.5) демонстрирует, как
выполнять итерации по файлам и подкаталогам с помощью функции filepath.Walk(). Кроме того, тип os.File из пакета os в стандартной библиотеке реализует методы чтения имен в каталоге (os.
File.Readdirnames() ) и извлечения значений типа os.FileInfo для
каждого элемента в каталоге (os.File.Readdir() ).
В первом разделе этой главы рассказывается, как писать и читать
файлы стандартных и пользовательских форматов. Второй раздел
охватывает поддержку обработки файлов-архивов и сжатых файлов.

## 8.1. Файлы с пользовательскими данными

Для программ весьма характерно хранить данные во внутреннем
представлении и предоставлять возможность импорта/экспорта
для поддержки обмена данными, а также чтобы упростить обработку данных внешними инструментами. Поскольку здесь речь идет
об обработке файлов, основное внимание будет сосредоточено исключительно на том, как писать и читать данные в стандартных и
пользовательских форматах в/из внутреннего их представления в
программе.

Во всех примерах в этом разделе будут использоваться одни и те
же данные, чтобы получить возможность сравнить различные форматы файлов. Весь программный код взят из программы invoicedata
(файлы invoicedata.go, gob.go, inv.go, jsn.go, txt.go и xml.go в каталоге invoicedata). Эта программа принимает в виде аргументов
командной строки имена двух файлов, один для чтения и один для
записи (то есть это должны быть разные имена файлов). Затем она
читает данные из первого файла (формат представления которых
определяется по расширению в имени файла) и записывает их во
второй файл (опять же, в формате, определяемом по расширению
в имени файла).

Файлы, созданные программой invoicedata, являются кроссплатформенными, то есть файл, созданный в Windows, сможет быть
прочитан в Mac OS X и Linux, и наоборот, независимо от формата.
Сжатые gzip-файлы (например, invoices.gob.gz) могут читаться и
записываться программой без применения дополнительных инструментов (вопросы сжатия файлов рассматриваются во втором разделе (§8.2)).

Данные в программе хранятся в виде значения типа []*Invoice, то
есть в виде среза с указателями на значения типа Invoice. Информация о каждой накладной 1 хранится в виде значения типа Invoice,
и каждая накладная содержит нуль или более пунктов в своем поле
Items типа []*Item (срез с указателями на значения типа Item).

{% highlight go %}
type Invoice struct {
    Id         int
    CustomerId int
    Raised     time.Time
    Due        time.Time
    Paid       bool
    Note       string
    Items      []*Item
}

type Item struct {
    Id       string
    Price    float64
    Quantity int
    Note     string
}
{% endhighlight %}

Эти две структуры используются для хранения данных. В табл.
8.1 показаны некоторые результаты измерения времени чтения и
записи одних и тех же 50 000 накладных, и размеры файлов каждого поддерживаемого формата. Результаты измерения времени
приводятся в секундах, с округлением до ближайшей десятой доли
секунды, их не следует рассматривать как абсолютные значения,
потому что на разных компьютерах, несомненно, будут получены
разные результаты. В столбце «Размер» приводятся размеры файлов в килобайтах – эти значения не должны изменяться на разных
компьютерах. Для данного набора данных размеры сжатых файлов
удивительно близки друг к другу, даже при том, что размеры несжатых файлов значительно отличаются. В столбце, где приводится
количество строк программного кода, не учитывается код, общий
для всех форматов (например, код сжатия и распаковывания, а также объявления структур).

!["Таблица 8.1. Сравнительные характеристики скорости обработки и размеров различных форматов"](/images/ris-8-0.jpg "Таблица 8.1. Сравнительные характеристики скорости обработки и размеров различных форматов")

Результаты хронометража и размеры файлов вполне ожидаемы,
кроме разве что необычно высокой скорости чтения и записи данных
в простом текстовом формате. Это обусловлено сочетанием прекрасной реализации функций ввода и вывода в пакете fmt и специального текстового формата, созданного с целью максимально упростить
парсинг данных. В реализации поддержки форматов JSON и XML
вместо формата по умолчанию для значений типа time.Time (строки в формате ISO-8601, включающие дату и время) сохраняется
только дата. Это позволило немного уменьшить размеры файлов за
счет незначительной потери скорости обработки и дополнительного
программного кода. Например, программный код, обрабатывающий
формат JSON , мог бы выполняться быстрее и занимал бы примерно столько же строк, сколько занимает программный код обработки
двоичного формата Go, если бы преобразования значений типа time.
Time выполнялись самой реализацией поддержки формата JSON.

Из двоичных форматов наиболее удобным является двоичный
формат Go – он очень быстрый, чрезвычайно компактный, для его
поддержки требуется небольшой объем программного кода, и он относительно просто адаптируется к изменениям в данных. Однако
при использовании пользовательских типов данных, которые изначально не поддерживают формат gob, необходимо реализовать в
них методы интерфейсов gob.Encoder и gob.Decoder, это может существенно замедлить операции чтения и записи данных в формате
gob, а также привести к раздуванию размеров файлов.

С точки зрения восприятия человека, лучшим форматом представления данных является, пожалуй, формат XML , в частности потому, что он широко распространен, как формат обмена данными.
Для обработки формата XML потребовалось больше программного
кода, чем для формата JSON. Это обусловлено тем, что в версии
Go 1 отсутствует xml.Marshaler (который, как ожидается, появится
в одной из более поздних версий Go 1.x), а также использованием
параллельных типов для упрощения отображения данных между
XML-форматом (XMLInvoice и XMLItem) и внутренним представлением (Invoice и Item). Приложения, экспортирующие свои данные
в формате XML, могут не использовать параллельные типы данных
или преобразования, используемые в программе invoicedata, поэтому они могут выполняться быстрее и занимать меньше строк программного кода, чем программа invoicedata.

Кроме скорости чтения и записи, размеров файлов и количества
строк программного кода, существует еще одна проблема, которую
необходимо учитывать: надежность формата. Например, если добавить одно поле в структуру Invoice и одно поле в структуру Item,
это потребует изменить форматы файлов. Как проще адаптировать
программный код для чтения и записи нового формата, сохранив
при этом возможность чтения старого формата? Добавив анализ
информации о версии в описание форматов файлов, подобного рода адаптация реализуется достаточно просто (как демонстрирует
одно из упражнений к этой главе), исключение составляет только формат JSON, для которого адаптация программного кода для
чтения и записи старого и нового форматов реализуется немного
сложнее.

В дополнение к структурам Invoice и Item в реализациях поддержки форматов файлов используются следующие константы:

{% highlight go %}
const (
    fileType             = "INVOICES"   // Используется текстовыми форматами
    magicNumber          = 0x125D       // Используется двоичными форматами
    fileVersion          = 100          // Используется всеми форматами
    dateFormat           = "2006-01-02" // Эта дата всегда должна использоваться
    nanosecondsToSeconds = 1e9
)
{% endhighlight %}

Константа magicNumber используется для идентификации файлов
с накладными 1 . Константа fileVersion определяет версию формата
файлов с накладными – ее использование упростит возможность
изменения программы в будущем для адаптации к изменениям в
структуре данных. Константа dateFormat демонстрирует, как форматируются даты, и будет обсуждаться ниже.

Здесь также определена пара интерфейсов.

{% highlight go %}
type InvoicesMarshaler interface {
    MarshalInvoices(writer io.Writer, invoices []*Invoice) error
}

type InvoicesUnmarshaler interface {
    UnmarshalInvoices(reader io.Reader) ([]*Invoice, error)
}
{% endhighlight %}

Их цель – упростить чтение и запись специализированных форматов обобщенным способом. Например, ниже приводится функция
из программы invoicedata, используемая для чтения накладных из
открытого файла.

{% highlight go %}
func readInvoices(reader io.Reader, suffix string) ([]*Invoice, error) {
    var unmarshaler InvoicesUnmarshaler
    switch suffix {
    case ".gob":
        unmarshaler = GobMarshaler{}
    case ".inv":
        unmarshaler = InvMarshaler{}
    case ".jsn", ".json":
        unmarshaler = JSONMarshaler{}
    case ".txt":
        unmarshaler = TxtMarshaler{}
    case ".xml":
        unmarshaler = XMLMarshaler{}
    }
    if unmarshaler != nil {
        return unmarshaler.UnmarshalInvoices(reader)
    }
    return nil, fmt.Errorf("unrecognized input suffix: %s", suffix)
}
{% endhighlight %}

Аргумент reader – это значение любого типа, реализующего интерфейс io.Reader , такое как открытый файл (типа *os.File), декомпрессор gzip (типа *gzip.Reader) или значение типа string.Reader.
Аргумент suffix – расширение имени файла (оставшееся после
удаления расширения .gz). Структуры GobMarshaler, InvMarshaler
и др. – это пользовательские типы, реализующие методы MarshalInvoices() и UnmarshalInvoices() (и, соответственно, реализующие
интерфейсы InvoicesMarshaler и InvoicesUnmarshaler), как будет показано в следующих подразделах.