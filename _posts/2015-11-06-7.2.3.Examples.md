---
layout: post
title:  "7.2.3. Пример: поточно-ориентированное отображение"
date:   2015-11-06 20:00:00
categories: go
---

Пакеты sync и sync/atomic из стандартной библиотеки предоставляют низкоуровневые операции, необходимые для реализации
поточно-ориентированных алгоритмов и структур данных. Однако
точно так же можно взять за основу имеющуюся структуру данных,
такую как отображение или срез (или omap.Map; §6.5.3), и превратить
ее в поточно-ориентированную, снабдив механизмом на основе высокоуровневых каналов, гарантирующим очередность операций доступа .

В этом подразделе будет создано поточно-ориентированное отображение с ключами типа string и значениями типа interface{}
(то есть любыми значениями), которое может совместно использоваться множеством go-подпрограмм без применения блокировок.
(Конечно, если сохранять в отображении указатели или ссылки на
значения, они должны интерпретироваться как доступные только
для чтения, или следует предусмотреть механизм, гарантирующий
очередность операций доступа к ним.) Реализация поточно-ориентированного отображения находится в файле safemap/safemap.go и
содержит экспортируемый интерфейс SafeMap, определяющий методы обеспечения безопасного доступа к отображению, и неэкспортируемый конкретный тип safeMap, реализующий этот интерфейс.
Практическое применение поточно-ориентированного отображения
будет продемонстрировано в следующем подразделе (§7.2.4).

Безопасность отображения обеспечивается неэкспортируемым
методом, заключающим отображение в go-подпрограмму. Единственный способ получить доступ к отображению – использовать
каналы, и этого уже достаточно, чтобы обеспечить очередность операций доступа. Метод выполняет бесконечный цикл, извлекая значения из канала ввода, который блокируется в ожидании команд
(таких как «вставить это значение», «удалить этот элемент» и т. д.).

Для начала познакомимся с интерфейсом SafeMap, затем с экспортируемыми методами типа safeMap, далее с функцией New() из пакета
safemap и, наконец, с неэкспортируемым методом safeMap.run().

{% highlight go %}
type SafeMap interface {
	Insert(string, interface{})
	Delete(string)
	Find(string) (interface{}, bool)
	Len() int
	Update(string, UpdateFunc)
	Close() map[string]interface
	interface{}
}
type UpdateFunc func(interface{}, bool) interface{}
{% endhighlight %}

Все эти методы реализуются типом safeMap. (Шаблон использования экспортируемого интерфейса и неэкспортируемого конкретного
типа рассматривался в предыдущей главе.)

Тип UpdateFunc определяет сигнатуру функции обновления: она
будет рассматриваться после знакомства с методом Update() ниже.

{% highlight go %}
type safeMap chan commandData
type commandData struct {
	action commandAction
	key
	string
	value interface{}
	result chan<- interface{}
	chan<- map[string]interface{}
	data
	updater UpdateFunc
}
type commandAction int
const (
	remove commandAction = iota
	end
	find
	insert
	length
	update
)
{% endhighlight %}

Тип safeMap основан на канале, посредством которого можно посылать и принимать значения типа commandData. Каждое значение
commandData определяет операцию и данные, участвующие в этой
операции, например большинство методов требуют ключа для идентификации элемента. Подробнее все поля будут описываться при
знакомстве с методами типа safeMap.

Обратите внимание, что оба канала, result и data, объявлены как
однонаправленные. Иными словами, поточно-ориентированное отображение само может посылать значения в них, но не может принимать значения из них. Как будет показано ниже, методы, создающие эти каналы, создают их двунаправленными, благодаря чему эти
каналы могут использоваться для приема всего, что в них посылает
поточно-ориентированное отображение.

{% highlight go %}
func (sm safeMap) Insert(key string, value interface{}) {
	sm <- commandData{action: insert, key: key, value: value}
}
{% endhighlight %}

Этот метод является безопасным эквивалентом инструкции m[key]
= value, где m – значение типа map[string] interface{}. Он создает
значение типа commandData с командой insert, указанным ключом key
и значением value, и посылает его поточно-ориентированному отображению, которое, как было показано выше, имеет тип chan commandData.
(Порядок создания значений составных типов, когда инициализируются лишь отдельные поля, был показан ранее, в §6.4.)

При обзоре функции New() из пакета safemap будет показано, что
значение типа safeMap возвращается функцией New() (как интерфейс SafeMap) уже связанным с go-подпрограммой. Метод safeMap.
run() выполняется в go-подпрограмме и образует замыкание, заключающее канал safeMap. Метод также содержит в себе фактическое
отображение, используемое для хранения элементов, и цикл for,
который производит итерации по элементам в канале safeMap и выполняет команды, принимаемые из канала.

{% highlight go %}
func (sm safeMap) Delete(key string) {
	sm <- commandData{action: remove, key: key}
}
{% endhighlight %}

Этот метод посылает команду на удаление элемента с указанным
ключом.

{% highlight go %}
type findResult struct {
	interface{}
	value interface
	found bool
}
func (sm safeMap) Find(key string) (value interface{}, found bool) {
	reply := make(chan interface{})
	sm <- commandData{action: find, key: key, result: reply}
	result := (<-reply).(findResult)
	return result.value, result.found
}
{% endhighlight %}

Метод safeMap.Find() создает собственный канал reply, чтобы
получить ответ от поточно-ориентированного отображения, которое
может только посылать данные в канал reply, и затем посылает поточно-ориентированному отображению команду find с указанным
ключом и собственным каналом reply. Поскольку ни один из каналов не имеет буфера, операция посылки данных блокируется, пока
поточно-ориентированное отображение не обработает запросы от
других go-подпрограмм. После посылки команды метод немедленно получает ответ (в виде структуры findResult для команды find),
элементы которого возвращаются вызывающей программе. Именованные возвращаемые значения здесь используются, только чтобы
сделать их назначение более очевидным.

{% highlight go %}
func (sm safeMap) Len() int {
	reply := make(chan interface{})
	sm <- commandData{action: length, result: reply}
	return (<-reply).(int)
}
{% endhighlight %}

Этот метод имеет такую же структуру, что и метод Find(), – он
создает и посылает собственный канал reply и передает полученный
ответ вызывающей программе.

{% highlight go %}
func (sm safeMap) Update(key string, updater UpdateFunc) {
	sm <- commandData{action: update, key: key, updater: updater}
}
{% endhighlight %}

На первый взгляд, имя этого метода кажется несоответствующим его сигнатуре, согласно которой во втором аргументе он принимает функцию типа func(interface{}, bool) interface{} (см.
выше). Метод посылает поточно-ориентированному отображению
команду update с ключом key и функцией updater. При выполнении
команды будет вызвана функция updater со значением элемента,
соответствующего указанному ключу (или nil, если такой элемент
отсутствует), и значение типа bool, указывающее на присутствие
элемента. Элементу будет присвоено значение, возвращаемое
функцией updater (при необходимости будет создан новый элемент
с указанным ключом key и значением, полученным от функции
updater).

Важно отметить, что если функция updater вызовет метод типа
safeMap, возникнет ситуация взаимоблокировки! Причины этого будут описываться при знакомстве с методом safemap.safeMap.run()
ниже.

Но зачем нужен этот странный метод и как им пользоваться?

Когда необходимо вставить, удалить или отыскать элемент в поточно-ориентированном отображении, можно воспользоваться методами Insert(), Delete() и Find(). Но как быть, если необходимо изменить значение имеющегося элемента? Например, представьте, что
отображение используется для хранения цен на различные товары и
необходимо увеличить цену некоторого товара на 5%. При использовании обычного отображения можно просто записать m[key] *=
1.05. В этом случае, если элемент с ключом key существует, его значение будет увеличено на 5%, в противном случае, благодаря автоматической инициализации новых переменных нулевыми значениями,
будет создан новый элемент с ключом key и с нулевым значением.
Ниже показано, как можно попытаться реализовать то же самое при
использовании поточно-ориентированного отображения, хранящего
значения типа float64.

{% highlight go %}
if price, found := priceMap.Find(part); found { // ОШИБКА!
	priceMap.Insert(part, price.(float64)*1.05)
}
{% endhighlight %}

Проблема здесь в том, что одно и то же отображение priceMap
может совместно использоваться несколькими go-подпрограммами,
которые могут одновременно попытаться изменить его содержимое
между вызовами методов Find() и Insert() в этом фрагменте. Поэтому нет никакой гарантии, что к моменту вызова метода Insert()
новая цена действительно будет на 5% больше цены, хранящейся в
этот момент в отображении.

Подобные операции должны выполняться атомарно , то есть извлечение и изменение значения должны выполняться как единая, непрерываемая операция. Именно это и обеспечивает метод Update().

{% highlight go %}
priceMap.Update(part, func(price interface{}, found bool) interface{} {
	if found {
		return price.(float64) * 1.05
	}
	return 0.0
})
{% endhighlight %}

Этот фрагмент демонстрирует, как выполняется атомарное обновление. Если элемент с указанным ключом отсутствует, будет создан
новый элемент со значением 0.0. В противном случае значение существующего элемента будет увеличено на 5%. Поскольку обновление
в ответ на команду update выполняется в рамках go-подпрограммы
поточно-ориентированного отображения, никакие другие команды
(например, из другой go-подпрограммы) не могут быть выполнены
в это же время.

{% highlight go %}
func (sm safeMap) Close() map[string]interface{} {
	reply := make(chan map[string]interface{})
	sm <- commandData{action: end, data: reply}
	return <-reply
}
{% endhighlight %}

Метод Close() действует подобно методам Find() и Len(), но
преследует две разные цели. Во-первых, он закрывает канал типа
safeMap (внутри метода safeMap.run()), что делает невозможным
дальнейшее изменение отображения. Это вызывает завершение цикла for ... range в методе safeMap.run() и тем самым освобождает
go-подпрограмму для утилизации сборщиком мусора. Во-вторых,
он возвращает фактическое отображение map[string]interface{},
которое вызывающая программа может сохранить или отбросить.
Метод Close() может быть вызван только один раз, независимо от
количества go-подпрограмм, обращающихся к отображению, и после его вызова никакой другой метод не может быть вызван. Это
означает, что если сохранить полученное отображение, к нему можно свободно обращаться как к обычному отображению (то есть в
единственной go-подпрограмме).

На этом завершается обзор экспортируемых методов типа safeMap.
Осталось лишь познакомиться с функцией New() в пакете safemap,
создающей и возвращающей значение типа safeMap как интерфейс
SafeMap для использования за пределами пакета, и с методом safeMap.
run(), хранящим канал, предоставляющим значение типа map[string]
interface{} для хранения данных и обрабатывающим все команды.

{% highlight go %}
func New() SafeMap {
	sm := make(safeMap) // тип safeMap chan commandData
	go sm.run()
	return sm
}
{% endhighlight %}

safeMap – это тип chan commandData, поэтому для создания канала
и получения ссылки на него необходимо использовать встроенную
функцию make(). После создания поточно-ориентированного отображения вызывается его неэкспортируемый метод run(), создающий фактическое отображение и принимающий команды. Метод
run() выполняется в собственной go-подпрограмме, и, как обычно,
инструкция go возвращает управление немедленно. В конце функция New() возвращает значение типа safeMap как интерфейс SafeMap.

{% highlight go %}
func (sm safeMap) run() {
    store := make(map[string]interface{})
    for command := range sm {
        switch command.action {
        case insert:
            store[command.key] = command.value
        case remove:
            delete(store, command.key)
        case find:
            value, found := store[command.key]
            command.result <- findResult{value, found}
        case length:
            command.result <- len(store)
        case update:
            value, found := store[command.key]
            store[command.key] = command.updater(value, found)
        case end:
            close(sm)
            command.data <- store
        }
    }
}
{% endhighlight %}

После создания фактического отображения метод run() начинает
выполнять бесконечный цикл, производящий итерации по элементам канала, блокируясь в моменты, когда в канале отсутствуют какие-либо команды.

Поскольку отображение store – не более чем обычное отображение, все операции, выполняемые в ответ на получение соответствующих команд, должны быть понятны. Единственный сложный
момент здесь – это обработка команды update, где значению элемента присваивается значение, возвращаемое функцией command.
updater() (описанной выше). Раздел end соответствует вызову метода Close(). Здесь сначала закрывается канал для предотвращения приема дальнейших команд, и затем фактическое отображение
посылается обратно.

Обратите внимание, что если функция command.updater() выполнит вызов метода типа safeMap, возникнет ситуация взаимоблокировки. Это обусловлено тем, что обработка команды update не может
завершиться, пока command.updater() не вернет управление, но если
функция вызовет метод типа safeMap, этот вызов заблокируется в
ожидании завершения обработки текущей команды, то есть ни то,
ни другое не смогут завершиться. Эта разновидность взаимоблокировок изображена на рис. 7.2 выше.

Очевидно, что использование поточно-ориентированного отображения сопряжено с дополнительными накладными расходами в
сравнении с обычным отображением. Для выполнения каждой команды требуется создать структуру commandData и послать ее в канал,
при этом команды, которые могут посылаться сколь угодно большим количеством go-подпрограмм, выполняются строго поочередно. Одно из альтернативных решений заключается в использовании
обычного отображения, доступ к которому защищается с помощью
значения типа sync.Mutex или sync.RWMutex . Другое альтернативное
решение состоит в создании собственной поточно-ориентированной
структуры, подобной тем, что описываются в литературе (например, см. «The Art of Multiprocessor Programming» в приложении C
ниже). Еще одно альтернативное решение заключается в том, чтобы
в каждой go-подпрограмме создавать собственное отображение, дабы полностью исключить необходимость синхронизации, и в конце
объединять их. Тем не менее поточно-ориентированное отображение, описанное здесь, удобно в использовании и может пригодиться
во многих ситуациях. Практическое использование поточно-ориентированного отображения будет демонстрироваться в следующем
подразделе наряду с парой альтернативных решений, для сравнения.

